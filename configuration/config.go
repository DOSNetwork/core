package configuration

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/DOSNetwork/core/onchain"
)

const ENVCHAINTYPE = "CHAINTYPE"
const ENVCHAINNODE = "CHAINNODE"
const ENVCONFIGPATH = "CONFIGPATH"
const ENVNODEROLE = "NODEROLE"
const ENVBOOTSTRAPIP = "BOOTSTRAPIP"
const ENVNODEPORT = "NODEPORT"
const CONFIGMODE = "TESTMODE"
const ENVGROUPSIZE = "GROUPSIZE"

type Config struct {
	NodeRole        string
	BootStrapIp     string
	Port            int
	RandomGroupSize int
	QueryGroupSize  int
	ChainConfigs    []onchain.ChainConfig
}

func ReadConfig() (config Config) {
	var workingDir string
	var err error

	path := os.Getenv(ENVCONFIGPATH)
	if path != "" {
		workingDir = path
	} else {
		workingDir, err = os.Getwd()
		if err != nil {
			return
		}
	}
	// Open our jsonFile
	jsonFile, err := os.Open(workingDir + "/config.json")
	// if we os.Open returns an error then handle it
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("Successfully Opened NetConfigs json")
	// defer the closing of our jsonFile so that we can parse it later on
	defer jsonFile.Close()

	// read our opened xmlFile as a byte array.
	byteValue, err := ioutil.ReadAll(jsonFile)
	if err != nil {
		log.Fatal(err)
	}
	err = json.Unmarshal(byteValue, &config)
	if err != nil {
		log.Fatal(err)
	}

	bootStrapIP := os.Getenv(ENVBOOTSTRAPIP)
	if bootStrapIP != "" {
		config.BootStrapIp = bootStrapIP
	}

	envSize := os.Getenv(ENVGROUPSIZE)
	if envSize != "" {
		size, err := strconv.Atoi(envSize)
		if err != nil {
			log.Fatal(err)
		}
		config.RandomGroupSize = size
		config.QueryGroupSize = size
	}

	nodeRole := os.Getenv(ENVNODEROLE)
	if nodeRole != "" {
		config.NodeRole = nodeRole
	}
	//---------------------------------
	if nodeRole == "testNode" {
		fmt.Println("This is a test node : ", config.BootStrapIp)
		s := strings.Split(config.BootStrapIp, ":")
		ip, _ := s[0], s[1]
		tServer := "http://" + ip + ":8080/getCredential"
		// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
		resp, err := http.Get(tServer)
		//start := time.Now()
		for err != nil {
			time.Sleep(1 * time.Second)
			resp, err = http.Get(tServer)
		}

		credential, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Fatalln(err)
		}
		fmt.Println("credential : ", string(credential))
		credentialPath := workingDir + "/credential/usrKey"
		err = ioutil.WriteFile(credentialPath, []byte(credential), 0644)
		resp.Body.Close()
		if err != nil {
			fmt.Println(err)
			log.Fatal(err)
		}
	}
	//---------------------------------

	port := os.Getenv(ENVNODEPORT)
	if port != "" {
		i, err := strconv.Atoi(port)
		if err == nil {
			config.Port = i
		}
	}
	return
}

func UpdateOnChainConfig(path string, config Config, updated onchain.ChainConfig) (err error) {
	chainType := os.Getenv(ENVCHAINTYPE)
	if chainType == "" {
		fmt.Println("No CHAINTYPE Environment variable.")
		chainType = "ETH"
	}
	chainNode := os.Getenv(ENVCHAINNODE)
	if chainNode == "" {
		fmt.Println("No CHAINNODE Environment variable.")
		chainNode = "rinkebyPrivateNode"
	}

	for i, c := range config.ChainConfigs {
		if chainNode == c.RemoteNodeType &&
			chainType == c.ChainType {
			config.ChainConfigs[i] = updated
		}
	}
	configsJson, _ := json.Marshal(config)
	err = ioutil.WriteFile(path, configsJson, 0644)
	return nil
}

func GetOnChainConfig(config Config) (node onchain.ChainConfig) {
	chainType := os.Getenv(ENVCHAINTYPE)
	if chainType == "" {
		fmt.Println("No CHAINTYPE Environment variable.")
		chainType = "ETH"
	}
	chainNode := os.Getenv(ENVCHAINNODE)
	if chainNode == "" {
		fmt.Println("No CHAINNODE Environment variable.")
		chainNode = "rinkebyPrivateNode"
	}

	for _, c := range config.ChainConfigs {
		if chainNode == c.RemoteNodeType &&
			chainType == c.ChainType {
			fmt.Println("Use : ", c)
			return c
		}
	}
	return onchain.ChainConfig{}
}
