// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package staking

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = abi.U256
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// StakingABI is the input ABI used to generate the binding from.
const StakingABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"inverseStakeRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOSTOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNodeAddrs\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodes\",\"outputs\":[{\"name\":\"ownerAddr\",\"type\":\"address\"},{\"name\":\"rewardCut\",\"type\":\"uint256\"},{\"name\":\"stakedDB\",\"type\":\"uint256\"},{\"name\":\"selfStakedAmount\",\"type\":\"uint256\"},{\"name\":\"totalOtherDelegatedAmount\",\"type\":\"uint256\"},{\"name\":\"accumulatedReward\",\"type\":\"uint256\"},{\"name\":\"accumulatedRewardRate\",\"type\":\"uint256\"},{\"name\":\"pendingWithdrawToken\",\"type\":\"uint256\"},{\"name\":\"pendingWithdrawDB\",\"type\":\"uint256\"},{\"name\":\"lastStartTime\",\"type\":\"uint256\"},{\"name\":\"lastStopTime\",\"type\":\"uint256\"},{\"name\":\"running\",\"type\":\"bool\"},{\"name\":\"description\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accumulatedRewardRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONEYEAR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeTryDelete\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"delegatorClaimReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"},{\"name\":\"_newTokenAmount\",\"type\":\"uint256\"},{\"name\":\"_newDropburnAmount\",\"type\":\"uint256\"},{\"name\":\"_newCut\",\"type\":\"uint256\"}],\"name\":\"updateNodeStaking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentAPR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalStakedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quota\",\"type\":\"uint256\"}],\"name\":\"setDropBurnMaxQuota\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_dropburnAmount\",\"type\":\"uint256\"},{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeUnbond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nodeAddr\",\"type\":\"address\"}],\"name\":\"getNodeRewardTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxStake\",\"type\":\"uint256\"}],\"name\":\"setMaxStakePerNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressBridge\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardRateDelta\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nodeAddr\",\"type\":\"address\"}],\"name\":\"getNodeUptime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_dropburnAmount\",\"type\":\"uint256\"},{\"name\":\"_rewardCut\",\"type\":\"uint256\"},{\"name\":\"_desc\",\"type\":\"string\"}],\"name\":\"newNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"delegatorChekcReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minStake\",\"type\":\"uint256\"}],\"name\":\"setMinStakePerNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bridgeAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DBDECIMAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"delegatorUnbond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxStakePerNode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegators\",\"outputs\":[{\"name\":\"delegatedNode\",\"type\":\"address\"},{\"name\":\"delegatedAmount\",\"type\":\"uint256\"},{\"name\":\"accumulatedReward\",\"type\":\"uint256\"},{\"name\":\"accumulatedRewardRate\",\"type\":\"uint256\"},{\"name\":\"pendingWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeUnregister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateGlobalRewardRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nodeAddr\",\"type\":\"address\"}],\"name\":\"isValidStakingNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"setUnbondDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSupply\",\"type\":\"uint256\"}],\"name\":\"setCirculatingSupply\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeClaimReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeAddrs\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeRunners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastRateUpdatedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"delegatorWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unbondDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOSDECIMAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeStop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRewardsVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_delegator\",\"type\":\"address\"},{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"getDelegatorRewardTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DBTOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minStakePerNode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dropburnMaxQuota\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nodeAddr\",\"type\":\"address\"}],\"name\":\"nodeChekcReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dostoken\",\"type\":\"address\"},{\"name\":\"_dbtoken\",\"type\":\"address\"},{\"name\":\"_vault\",\"type\":\"address\"},{\"name\":\"_bridgeAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldQuota\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newQuota\",\"type\":\"uint256\"}],\"name\":\"UpdateDropBurnMaxQuota\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"UpdateUnbondDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldCirculatingSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newCirculatingSupply\",\"type\":\"uint256\"}],\"name\":\"UpdateCirculatingSupply\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldMinStakePerNode\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newMinStakePerNode\",\"type\":\"uint256\"}],\"name\":\"UpdateMinStakePerNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldMaxStakePerNode\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newMaxStakePerNode\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxStakePerNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nodeAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"selfStakedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakedDB\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardCut\",\"type\":\"uint256\"}],\"name\":\"LogNewNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nodeAddr\",\"type\":\"address\"}],\"name\":\"DelegateTo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"RewardWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dropburnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nodeAddr\",\"type\":\"address\"}],\"name\":\"Unbond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// StakingBin is the compiled bytecode used for deploying new contracts.
const StakingBin = `6080604052690a968163f0a57b4000006004556969e10de76676d080000060055560036006556a6d257fd53db9e188c0000060095562093a80600a5534801561004757600080fd5b5060405160808061379d8339810180604052608081101561006757600080fd5b5080516020820151604083015160609093015160008054336001600160a01b03199182161782556001805482166001600160a01b039687161790556002805482169486169490941790935560038054841695851695909517909455600e805483169184169190911790819055600d80549190931691161790556136ad9081906100f090396000f3fe608060405234801561001057600080fd5b50600436106103275760003560e01c80638f32d59b116101b8578063b4a2649011610104578063cd45dbcb116100a2578063e5f95a991161007c578063e5f95a9914610a36578063e8c3470c14610a3e578063f2fde38b14610a46578063f94166e314610a6c57610327565b8063cd45dbcb146109f8578063d0e301f014610a00578063d2a0254114610a2e57610327565b8063c314bb99116100de578063c314bb991461099c578063c4393444146109c2578063c48f4d47146109ca578063c5375c29146109d257610327565b8063b4a2649014610949578063be4a455f14610966578063be5680591461099457610327565b8063a2526bd311610171578063a8e8ab381161014b578063a8e8ab38146108c3578063b16d2d58146108e9578063b176407114610906578063b41b0f961461092357610327565b8063a2526bd314610832578063a277219314610895578063a5e5b55e146108bb57610327565b80638f32d59b146107ca57806391874ef7146107e657806391bf6960146107ee5780639358928b146107f657806395d516dd146107fe5780639dccacc11461082a57610327565b80634c542d3d1161027757806376cffa5311610230578063867f121a1161020a578063867f121a146106b85780638ac801081461077f5780638b0bc845146107a55780638da5cb5b146107c257610327565b806376cffa53146106825780637c6250ff1461068a5780637f92ca191461069257610327565b80634c542d3d146105b95780634ecea80d146105df578063508b74fe146106055780635bfd61d4146106375780636b5fc6a61461065d578063715018a61461067a57610327565b8063195cb3ab116102e45780631ece5950116102be5780631ece59501461055457806321ae05c81461058c5780633ae73259146105945780633f3381e11461059c57610327565b8063195cb3ab146105005780631b602ec4146105085780631cac57ec1461052e57610327565b80630725b32e1461032c57806308bbb824146103465780630fd1d0ea146103745780631017bf5614610398578063189a5a17146103f0578063193b9497146104f8575b600080fd5b610334610a92565b60408051918252519081900360200190f35b6103726004803603604081101561035c57600080fd5b50803590602001356001600160a01b0316610a98565b005b61037c610dfd565b604080516001600160a01b039092168252519081900360200190f35b6103a0610e0c565b60408051602080825283518183015283519192839290830191858101910280838360005b838110156103dc5781810151838201526020016103c4565b505050509050019250505060405180910390f35b6104166004803603602081101561040657600080fd5b50356001600160a01b0316610e6f565b604051808e6001600160a01b03166001600160a01b031681526020018d81526020018c81526020018b81526020018a81526020018981526020018881526020018781526020018681526020018581526020018481526020018315151515815260200180602001828103825283818151815260200191508051906020019080838360005b838110156104b1578181015183820152602001610499565b50505050905090810190601f1680156104de5780820380516001836020036101000a031916815260200191505b509e50505050505050505050505050505060405180910390f35b610334610f8d565b610334610f93565b6103726004803603602081101561051e57600080fd5b50356001600160a01b0316610f9b565b6103726004803603602081101561054457600080fd5b50356001600160a01b03166111b9565b6103726004803603608081101561056a57600080fd5b506001600160a01b0381351690602081013590604081013590606001356113ae565b61033461167f565b6103346116d0565b610372600480360360208110156105b257600080fd5b50356116d6565b610372600480360360208110156105cf57600080fd5b50356001600160a01b0316611779565b610372600480360360208110156105f557600080fd5b50356001600160a01b0316611913565b6103726004803603606081101561061b57600080fd5b50803590602081013590604001356001600160a01b0316611a95565b6103346004803603602081101561064d57600080fd5b50356001600160a01b0316611d09565b6103726004803603602081101561067357600080fd5b5035611d7b565b610372611dce565b61037c611e27565b610334611e36565b610334600480360360208110156106a857600080fd5b50356001600160a01b0316611e5d565b610372600480360360a08110156106ce57600080fd5b6001600160a01b038235169160208101359160408201359160608101359181019060a08101608082013564010000000081111561070a57600080fd5b82018360208201111561071c57600080fd5b8035906020019184600183028401116401000000008311171561073e57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250929550611ea2945050505050565b6103346004803603602081101561079557600080fd5b50356001600160a01b03166123a0565b610372600480360360208110156107bb57600080fd5b5035612494565b61037c6124e7565b6107d26124f6565b604080519115158252519081900360200190f35b61037c612507565b610334612516565b61033461251b565b6103726004803603604081101561081457600080fd5b50803590602001356001600160a01b0316612521565b610334612743565b6108606004803603604081101561084857600080fd5b506001600160a01b0381358116916020013516612749565b604080516001600160a01b03909616865260208601949094528484019290925260608401526080830152519081900360a00190f35b610372600480360360208110156108ab57600080fd5b50356001600160a01b031661278d565b610372612835565b6107d2600480360360208110156108d957600080fd5b50356001600160a01b031661284c565b610372600480360360208110156108ff57600080fd5b50356128a7565b6103726004803603602081101561091c57600080fd5b50356128fa565b6103726004803603602081101561093957600080fd5b50356001600160a01b0316612993565b61037c6004803603602081101561095f57600080fd5b5035612a82565b6107d26004803603604081101561097c57600080fd5b506001600160a01b0381358116916020013516612aa9565b610334612ac9565b610372600480360360208110156109b257600080fd5b50356001600160a01b0316612acf565b610334612e41565b610334612e47565b610372600480360360208110156109e857600080fd5b50356001600160a01b0316612e4c565b61037c612f2e565b61033460048036036040811015610a1657600080fd5b506001600160a01b0381358116916020013516612f3d565b61037c612fd0565b610334612fdf565b610334612fe5565b61037260048036036020811015610a5c57600080fd5b50356001600160a01b0316612feb565b61033460048036036020811015610a8257600080fd5b50356001600160a01b0316613005565b60085481565b6001600160a01b038082166000908152600f602052604090208054909116610b025760408051600160e51b62461bcd0281526020600482015260126024820152600160721b71139bd91948191bd95cdb89dd08195e1a5cdd02604482015290519081900360640190fd5b80546001600160a01b0316331415610b645760408051600160e51b62461bcd02815260206004820152601f60248201527f4e6f6465206f776e65722063616e6e6f742073656c662d64656c656761746500604482015290519081900360640190fd5b600554838260040154836003015401011115610bb457604051600160e51b62461bcd02815260040180806020018281038252602b8152602001806135db602b913960400191505060405180910390fd5b3360009081526012602090815260408083206001600160a01b038681168552925290912080549091161580610bf5575080546001600160a01b038481169116145b610c495760408051600160e51b62461bcd02815260206004820152601e60248201527f496e76616c69642064656c656761746564206e6f646520616464726573730000604482015290519081900360640190fd5b600b82015460ff16151560011415610c7357610c63612835565b610c6d3384612f3d565b60028201555b600c5460038201556001810180548501905580546001600160a01b0316610cc15780546001600160a01b0319166001600160a01b038416178155600160008181526006830160205260409020555b600b82015460ff16151560011415610cea57610cdc83611d09565b600583015560078054850190555b600d8201805460018101825560009182526020918290200180546001600160a01b0319163390811790915560048401805487019055600c546006850155604080518781526001600160a01b03871693810193909352805191927f418fb73ed46b20c69a0bc31bf9eb2793aabeabd4c7fe2cd4760406115cf074c1929081900390910190a260015460408051600160e01b6323b872dd0281523360048201523060248201526044810187905290516001600160a01b03909216916323b872dd916064808201926020929091908290030181600087803b158015610dcb57600080fd5b505af1158015610ddf573d6000803e3d6000fd5b505050506040513d6020811015610df557600080fd5b505050505050565b6001546001600160a01b031681565b60606010805480602002602001604051908101604052809291908181526020018280548015610e6457602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610e46575b505050505090505b90565b600f6020528060005260406000206000915090508060000160009054906101000a90046001600160a01b03169080600101549080600201549080600301549080600401549080600501549080600601549080600701549080600801549080600901549080600a01549080600b0160009054906101000a900460ff169080600c018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610f835780601f10610f5857610100808354040283529160200191610f83565b820191906000526020600020905b815481529060010190602001808311610f6657829003601f168201915b505050505090508d565b600c5481565b6301e1338081565b6001600160a01b0381166000908152600f6020526040902060030154158015610fdd57506001600160a01b0381166000908152600f6020526040902060020154155b801561100257506001600160a01b0381166000908152600f6020526040902060040154155b801561102757506001600160a01b0381166000908152600f6020526040902060050154155b801561104c57506001600160a01b0381166000908152600f60205260409020600d0154155b156111b6576001600160a01b0381166000908152600f6020526040812080546001600160a01b0319168155600181018290556002810182905560038101829055600481018290556005810182905560068101829055600781018290556008810182905560098101829055600a8101829055600b8101805460ff19169055906110d7600c8301826132de565b6110e5600d83016000613322565b50600090505b60105481101561113457336001600160a01b03166010828154811061110c57fe5b6000918252602090912001546001600160a01b0316141561112c57611134565b6001016110eb565b6010548110156111b45760108054600019810190811061115057fe5b600091825260209091200154601080546001600160a01b03909216918390811061117657fe5b600091825260209091200180546001600160a01b0319166001600160a01b039290921691909117905560108054906111b2906000198301613340565b505b505b50565b3360009081526012602090815260408083206001600160a01b038581168552908352818420600f9093529220549091166112355760408051600160e51b62461bcd0281526020600482015260126024820152600160721b71139bd91948191bd95cdb89dd08195e1a5cdd02604482015290519081900360640190fd5b80546001600160a01b0383811691161461128357604051600160e51b62461bcd0281526004018080602001828103825260248152602001806134db6024913960400191505060405180910390fd5b61128b612835565b60006112973384612f3d565b9050816001015460001480156112af57506004820154155b15611303573360009081526012602090815260408083206001600160a01b0387168452909152812080546001600160a01b031916815560018101829055600281018290556003810182905560040155611313565b60006002830155600c5460038301555b600980548201905560015460035460408051600160e01b6323b872dd0281526001600160a01b03928316600482015233602482015260448101859052905191909216916323b872dd9160648083019260209291908290030181600087803b15801561137d57600080fd5b505af1158015611391573d6000803e3d6000fd5b505050506040513d60208110156113a757600080fd5b5050505050565b3360009081526011602090815260408083206001600160a01b038816845290915290205460ff166114295760408051600160e51b62461bcd02815260206004820152601f60248201527f4e6f6465206973206e6f74206f776e6564206279206d73672e73656e64657200604482015290519081900360640190fd5b6001600160a01b0384166000908152600f60205260409020600b81015460ff1615156001141561146a5761145b612835565b61146485611d09565b60058201555b600c54600682015560001982146114db57606482106114d35760408051600160e51b62461bcd02815260206004820152601f60248201527f4e6f742076616c696420726577617264206375742070657263656e7461676500604482015290519081900360640190fd5b600181018290555b82156115745760028082018054850190555460408051600160e01b6323b872dd0281523360048201523060248201526044810186905290516001600160a01b03909216916323b872dd916064808201926020929091908290030181600087803b15801561154757600080fd5b505af115801561155b573d6000803e3d6000fd5b505050506040513d602081101561157157600080fd5b50505b83156113a7576005548482600401548360030154010111156115ca57604051600160e51b62461bcd02815260040180806020018281038252602b8152602001806135db602b913960400191505060405180910390fd5b60038101805485019055600b81015460ff161515600114156115ef5760078054850190555b60015460408051600160e01b6323b872dd0281523360048201523060248201526044810187905290516001600160a01b03909216916323b872dd916064808201926020929091908290030181600087803b15801561164c57600080fd5b505af1158015611660573d6000803e3d6000fd5b505050506040513d602081101561167657600080fd5b50505050505050565b6000600754600014156116955750611f40610e6c565b600060075460095461271002816116a857fe5b04905062030d408111156116c157611f40915050610e6c565b601990049050610e6c565b5090565b60075481565b6116de6124f6565b6116e757600080fd5b60065481141580156116f95750600a81105b61173757604051600160e51b62461bcd0281526004018080602001828103825260248152602001806135b76024913960400191505060405180910390fd5b600654604080519182526020820183905280517f0aee95cca46da64ee373e28dee5994361b4002c54035d92932c9825b76382e999281900390910190a1600655565b600d60009054906101000a90046001600160a01b03166001600160a01b03166343a73d9a6040518163ffffffff1660e01b815260040160206040518083038186803b1580156117c757600080fd5b505afa1580156117db573d6000803e3d6000fd5b505050506040513d60208110156117f157600080fd5b50516001600160a01b031633146118525760408051600160e51b62461bcd02815260206004820152601760248201527f4e6f742066726f6d2070726f787920636f6e7472616374000000000000000000604482015290519081900360640190fd5b6001600160a01b0381166000908152600f60205260409020600b8101805460ff19166001179055426009820155611887612835565b600c54600682015560005b600d8201548110156118f95760006012600084600d0184815481106118b357fe5b60009182526020808320909101546001600160a01b03908116845283820194909452604092830182209388168252929092529020600c5460039091015550600101611892565b506004810154600390910154600780549190920101905550565b6001600160a01b038082166000908152600f602052604090208054909116331461197157604051600160e51b62461bcd0281526004018080602001828103825260328152602001806135266032913960400191505060405180910390fd5b60008061198483600f0184600e0161308f565b6007850180548390039055600885018054829003905590925090506119a884610f9b565b8115611a325760015460408051600160e01b63a9059cbb0281523360048201526024810185905290516001600160a01b039092169163a9059cbb916044808201926020929091908290030181600087803b158015611a0557600080fd5b505af1158015611a19573d6000803e3d6000fd5b505050506040513d6020811015611a2f57600080fd5b50505b8015611a8f5760025460408051600160e01b63a9059cbb0281523360048201526024810184905290516001600160a01b039092169163a9059cbb916044808201926020929091908290030181600087803b158015610dcb57600080fd5b50505050565b3360009081526011602090815260408083206001600160a01b038516845290915290205460ff16611b105760408051600160e51b62461bcd02815260206004820152601f60248201527f4e6f6465206973206e6f74206f776e6564206279206d73672e73656e64657200604482015290519081900360640190fd5b6001600160a01b0381166000908152600f602052604090206003810154841115611b6e57604051600160e51b62461bcd02815260040180806020018281038252603081526020018061362b6030913960400191505060405180910390fd5b8060020154831115611bb457604051600160e51b62461bcd0281526004018080602001828103825260398152602001806134a26039913960400191505060405180910390fd5b600b81015460ff16151560011415611be657611bce612835565b611bd782611d09565b60058201556007805485900390555b600c54600682015560038101805485900390556007810180548501905560028101805484900390556008810180548401905583151580611c265750600083115b15611c7d57600a546040805180820182528681526020808201878152429094016000818152600e87018352848120935184559451600193840155828552600f86019091528284208054828652938520939093559252555b600a611c9460018504836002015403600654613154565b600a036004540281611ca257fe5b048482600301540310611cb857611cb88261316c565b60408051858152602081018590526001600160a01b03841681830152905133917f1bcf1da2dc680801f7898e72d42550dffb4a3e26dd3a33ff2b23e9f4f6131e9e919081900360600190a250505050565b6001600160a01b0381166000908152600f60205260408120600b81015460ff1615611d6f576402540be4008160060154600c54036064836001015484600401540281611d5157fe5b048360030154010281611d6057fe5b04816005015401915050611d76565b6005015490505b919050565b611d836124f6565b611d8c57600080fd5b600554604080519182526020820183905280517f92b144c2e286a9707a25ca0bcb990cde2f7bb2547eb5af8a0191dff727b6e0899281900390910190a1600555565b611dd66124f6565b611ddf57600080fd5b600080546040516001600160a01b03909116917ff8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c6482091a2600080546001600160a01b0319169055565b600d546001600160a01b031681565b60006301e13380611e4561167f565b600b54420302620f42400281611e5757fe5b04905090565b6001600160a01b0381166000908152600f60205260408120600b81015460ff1615611e8f576009015442039050611d76565b806009015481600a015403915050611d76565b83838360648110611efd5760408051600160e51b62461bcd02815260206004820152601f60248201527f4e6f742076616c696420726577617264206375742070657263656e7461676500604482015290519081900360640190fd5b600a611f0f6001845b04600654613154565b600a036004540281611f1d57fe5b04831015611f5f57604051600160e51b62461bcd02815260040180806020018281038252602481526020018061347e6024913960400191505060405180910390fd5b600554831115611fa357604051600160e51b62461bcd02815260040180806020018281038252602b8152602001806135db602b913960400191505060405180910390fd5b3360009081526011602090815260408083206001600160a01b038c16845290915290205460ff161561201f5760408051600160e51b62461bcd02815260206004820152601a60248201527f4e6f646520697320616c72656164792072656769737465726564000000000000604482015290519081900360640190fd5b3360008181526011602090815260408083206001600160a01b038d81168552908352818420805460ff19166001908117909155548251600160e01b6323b872dd0281526004810196909652306024870152604486018d905291519116936323b872dd9360648083019493928390030190829087803b1580156120a057600080fd5b505af11580156120b4573d6000803e3d6000fd5b505050506040513d60208110156120ca57600080fd5b5050851561215c5760025460408051600160e01b6323b872dd0281523360048201523060248201526044810189905290516001600160a01b03909216916323b872dd916064808201926020929091908290030181600087803b15801561212f57600080fd5b505af1158015612143573d6000803e3d6000fd5b505050506040513d602081101561215957600080fd5b50505b6060604051806101c00160405280336001600160a01b031681526020018781526020018881526020018981526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160001515815260200186815260200182815250600f60008b6001600160a01b03166001600160a01b0316815260200190815260200160002060008201518160000160006101000a8154816001600160a01b0302191690836001600160a01b031602179055506020820151816001015560408201518160020155606082015181600301556080820151816004015560a0820151816005015560c0820151816006015560e082015181600701556101008201518160080155610120820151816009015561014082015181600a015561016082015181600b0160006101000a81548160ff02191690831515021790555061018082015181600c0190805190602001906122c6929190613364565b506101a082015180516122e391600d8401916020909101906133de565b5050506001600160a01b0389166000818152600f602081815260408084206001808652930182528084208390556010805493840181559093527f1b6847dc741a1b0cd08d278845f9d819d87b734759afb55fe2de5cb82a9ae67290910180546001600160a01b03191684179055815192835282018a9052818101899052606082018890525133917f30c92196901ae5c26b634311806ab8eb9b4c563bf3fa73946deeda237324446a919081900360800190a2505050505050505050565b3360009081526012602090815260408083206001600160a01b038581168552908352818420600f909352908320541661241b5760408051600160e51b62461bcd0281526020600482015260126024820152600160721b71139bd91948191bd95cdb89dd08195e1a5cdd02604482015290519081900360640190fd5b80546001600160a01b0384811691161461246957604051600160e51b62461bcd0281526004018080602001828103825260248152602001806134db6024913960400191505060405180910390fd5b612471612835565b61247b3384612f3d565b60028201819055600c5460039092019190915592915050565b61249c6124f6565b6124a557600080fd5b600454604080519182526020820183905280517f89892efa8f66455fa9bf996b1444e79778d71795cf00089fadf89071a3896ebb9281900390910190a1600455565b6000546001600160a01b031690565b6000546001600160a01b0316331490565b600e546001600160a01b031681565b600081565b60095481565b3360009081526012602090815260408083206001600160a01b038581168552908352818420600f90935292205490911661259d5760408051600160e51b62461bcd0281526020600482015260126024820152600160721b71139bd91948191bd95cdb89dd08195e1a5cdd02604482015290519081900360640190fd5b80546001600160a01b038381169116146125eb57604051600160e51b62461bcd0281526004018080602001828103825260258152602001806136066025913960400191505060405180910390fd5b806001015483111561263157604051600160e51b62461bcd0281526004018080602001828103825260278152602001806134ff6027913960400191505060405180910390fd5b6001600160a01b0382166000908152600f60205260409020600b015460ff161515600114156126a057612662612835565b61266c3383612f3d565b600282015560078054849003905561268382611d09565b6001600160a01b0383166000908152600f60205260409020600501555b600c805460038301556001820180548590039055600480830180548601905590546001600160a01b0384166000908152600f602052604090206006810191909155018054849003905582156111b257600a5460408051808201825285815260006020808301828152429095018083526005870182528483209351845594516001938401558282526006860190528281208054858352938220939093555255505050565b60055481565b6012602090815260009283526040808420909152908252902080546001820154600283015460038401546004909401546001600160a01b0390931693919290919085565b3360009081526011602090815260408083206001600160a01b038516845290915290205460ff166128085760408051600160e51b62461bcd02815260206004820152601f60248201527f4e6f6465206973206e6f74206f776e6564206279206d73672e73656e64657200604482015290519081900360640190fd5b6001600160a01b0381166000908152600f60205260409020600381015460028201546111b4919084611a95565b61283d611e36565b600c8054909101905542600b55565b6001600160a01b0381166000908152600f6020526040812060038101546002820154600a61287b600183611f06565b600a03600454028161288957fe5b04821061289c5760019350505050611d76565b506000949350505050565b6128af6124f6565b6128b857600080fd5b600a54604080519182526020820183905280517f8671d68a1c48206a7cde676b141ee222482f2014d09ad75af8f5ee2118af9b999281900390910190a1600a55565b6129026124f6565b61290b57600080fd5b600754600954101561295157604051600160e51b62461bcd0281526004018080602001828103825260308152602001806135876030913960400191505060405180910390fd5b600954604080519182526020820183905280517fef08ea314c41dc78bc73676b156d3b7802c096dd7a552f7f514a80967aba10ac9281900390910190a1600955565b6001600160a01b038082166000908152600f60205260409020805490911633146129f157604051600160e51b62461bcd02815260040180806020018281038252602f815260200180613558602f913960400191505060405180910390fd5b6129f9612835565b6000612a0483611d09565b600060058401819055600c546006850155600980548301905560015460035460408051600160e01b6323b872dd0281526001600160a01b0392831660048201523360248201526044810186905290519495509116926323b872dd92606480840193602093929083900390910190829087803b15801561137d57600080fd5b60108181548110612a8f57fe5b6000918252602090912001546001600160a01b0316905081565b601160209081526000928352604080842090915290825290205460ff1681565b600b5481565b3360009081526012602090815260408083206001600160a01b038581168552908352818420600f909352922054909116612b4b5760408051600160e51b62461bcd0281526020600482015260126024820152600160721b71139bd91948191bd95cdb89dd08195e1a5cdd02604482015290519081900360640190fd5b80546001600160a01b03838116911614612b9957604051600160e51b62461bcd02815260040180806020018281038252602781526020018061365b6027913960400191505060405180910390fd5b6000612bab826006018360050161308f565b5090508015612e385760048201805482900390556001820154158015612bd357506004820154155b8015612be157506002820154155b15612d7e573360009081526012602090815260408083206001600160a01b0387168452909152812080546001600160a01b03191681556001810182905560028101829055600381018290556004018190555b6001600160a01b0384166000908152600f60205260409020600d0154811015612ca8576001600160a01b0384166000908152600f60205260409020600d01805433919083908110612c8057fe5b6000918252602090912001546001600160a01b03161415612ca057612ca8565b600101612c33565b6001600160a01b0384166000908152600f60205260409020600d0154811015612d7c576001600160a01b0384166000908152600f60205260409020600d0180546000198101908110612cf657fe5b60009182526020808320909101546001600160a01b038781168452600f9092526040909220600d01805491909216919083908110612d3057fe5b600091825260208083209190910180546001600160a01b0319166001600160a01b039485161790559186168152600f90915260409020600d01805490612d7a906000198301613340565b505b505b60408051828152905133917f6553897c25961cd3a105492c25576d0552123ee868aca283e90f3b4224d7d177919081900360200190a260015460408051600160e01b63a9059cbb0281523360048201526024810184905290516001600160a01b039092169163a9059cbb916044808201926020929091908290030181600087803b158015612e0b57600080fd5b505af1158015612e1f573d6000803e3d6000fd5b505050506040513d6020811015612e3557600080fd5b50505b6111b283610f9b565b600a5481565b601281565b600d60009054906101000a90046001600160a01b03166001600160a01b03166343a73d9a6040518163ffffffff1660e01b815260040160206040518083038186803b158015612e9a57600080fd5b505afa158015612eae573d6000803e3d6000fd5b505050506040513d6020811015612ec457600080fd5b50516001600160a01b03163314612f255760408051600160e51b62461bcd02815260206004820152601760248201527f4e6f742066726f6d2070726f787920636f6e7472616374000000000000000000604482015290519081900360640190fd5b6111b68161316c565b6003546001600160a01b031681565b6001600160a01b038082166000818152600f60209081526040808320948716835260128252808320938352929052908120600b83015491929160ff1615612fbd576402540be4008160030154600c54036064846001015460640384600101540281612fa457fe5b040281612fad57fe5b0481600201540192505050612fca565b600201549150612fca9050565b92915050565b6002546001600160a01b031681565b60045481565b60065481565b612ff36124f6565b612ffc57600080fd5b6111b681613270565b6001600160a01b038082166000908152600f6020526040812080549192909116331461306557604051600160e51b62461bcd02815260040180806020018281038252602f815260200180613558602f913960400191505060405180910390fd5b61306d612835565b61307683611d09565b60058201819055600c5460069092019190915592915050565b600160008181526020849052604081205490918291829182915b600181141580156130b957504281115b156130d5576000818152602089905260409020549091506130a9565b6000828152602089905260409020546001146130fe576000828152602089905260409020600190555b5b600181146131475760008181526020888152604080832080546001820180548e8652938620805490879055948d905291859055939055959091019493909301929091506130ff565b5091969095509350505050565b60008183106131635781613165565b825b9392505050565b6001600160a01b0381166000908152600f6020526040902061318c612835565b61319582611d09565b6005820155600c54600682015560005b600d8201548110156132425760006012600084600d0184815481106131c657fe5b60009182526020808320909101546001600160a01b03908116845283820194909452604092830182209388168252929092529020600d8401805491925061322c918490811061321157fe5b6000918252602090912001546001600160a01b031685612f3d565b6002820155600c546003909101556001016131a5565b50600b8101805460ff19169055600481015460038201546007805492909103909103905542600a9091015550565b6001600160a01b03811661328357600080fd5b600080546040516001600160a01b03808516939216917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e091a3600080546001600160a01b0319166001600160a01b0392909216919091179055565b50805460018160011615610100020316600290046000825580601f1061330457506111b6565b601f0160209004906000526020600020908101906111b6919061343f565b50805460008255906000526020600020908101906111b6919061343f565b8154818355818111156111b2576000838152602090206111b291810190830161343f565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106133a557805160ff19168380011785556133d2565b828001600101855582156133d2579182015b828111156133d25782518255916020019190600101906133b7565b506116cc92915061343f565b828054828255906000526020600020908101928215613433579160200282015b8281111561343357825182546001600160a01b0319166001600160a01b039091161782556020909201916001909101906133fe565b506116cc929150613459565b610e6c91905b808211156116cc5760008155600101613445565b610e6c91905b808211156116cc5780546001600160a01b031916815560010161345f56fe4e6f7420656e6f75676820646f7320746f6b656e20746f2073746172742061206e6f6465496e76616c6964207265717565737420746f20756e626f6e64206d6f7265207468616e207374616b65642044726f704275726e20746f6b656e43616e6e6f7420636c61696d2066726f6d206e6f6e2d64656c656761746564206e6f646543616e6e6f7420756e626f6e64206d6f7265207468616e2064656c65676174656420746f6b656e6d73672e73656e646572206973206e6f7420617574686f72697a656420746f2077697468647261772066726f6d206e6f64656d73672e73656e646572206973206e6f7420617574686f72697a656420746f20636c61696d2066726f6d206e6f646543697263756c6174696e67537570706c79206973206c657373207468616e20746f74616c5374616b6564546f6b656e7356616c69642064726f706275726e4d617851756f74612077697468696e203020746f20395265616368206d6178696d756d206e756d626572206f6620646f7320746f6b656e7320706572206e6f646543616e6e6f7420756e626f6e642066726f6d206e6f6e2d64656c656761746564206e6f6465496e76616c6964207265717565737420746f20756e626f6e64206d6f7265207468616e207374616b656420746f6b656e43616e6e6f742077697468647261772066726f6d206e6f6e2d64656c656761746564206e6f6465a165627a7a7230582093dee205a8253a51d6835cf1199a1e311453a48071031491c5ae4124784f548d0029`

// DeployStaking deploys a new Ethereum contract, binding an instance of Staking to it.
func DeployStaking(auth *bind.TransactOpts, backend bind.ContractBackend, _dostoken common.Address, _dbtoken common.Address, _vault common.Address, _bridgeAddr common.Address) (common.Address, *types.Transaction, *Staking, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(StakingBin), backend, _dostoken, _dbtoken, _vault, _bridgeAddr)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Staking{StakingCaller: StakingCaller{contract: contract}, StakingTransactor: StakingTransactor{contract: contract}, StakingFilterer: StakingFilterer{contract: contract}}, nil
}

// Staking is an auto generated Go binding around an Ethereum contract.
type Staking struct {
	StakingCaller     // Read-only binding to the contract
	StakingTransactor // Write-only binding to the contract
	StakingFilterer   // Log filterer for contract events
}

// StakingCaller is an auto generated read-only Go binding around an Ethereum contract.
type StakingCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StakingTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StakingFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StakingSession struct {
	Contract     *Staking          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StakingCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StakingCallerSession struct {
	Contract *StakingCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// StakingTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StakingTransactorSession struct {
	Contract     *StakingTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// StakingRaw is an auto generated low-level Go binding around an Ethereum contract.
type StakingRaw struct {
	Contract *Staking // Generic contract binding to access the raw methods on
}

// StakingCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StakingCallerRaw struct {
	Contract *StakingCaller // Generic read-only contract binding to access the raw methods on
}

// StakingTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StakingTransactorRaw struct {
	Contract *StakingTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStaking creates a new instance of Staking, bound to a specific deployed contract.
func NewStaking(address common.Address, backend bind.ContractBackend) (*Staking, error) {
	contract, err := bindStaking(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Staking{StakingCaller: StakingCaller{contract: contract}, StakingTransactor: StakingTransactor{contract: contract}, StakingFilterer: StakingFilterer{contract: contract}}, nil
}

// NewStakingCaller creates a new read-only instance of Staking, bound to a specific deployed contract.
func NewStakingCaller(address common.Address, caller bind.ContractCaller) (*StakingCaller, error) {
	contract, err := bindStaking(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StakingCaller{contract: contract}, nil
}

// NewStakingTransactor creates a new write-only instance of Staking, bound to a specific deployed contract.
func NewStakingTransactor(address common.Address, transactor bind.ContractTransactor) (*StakingTransactor, error) {
	contract, err := bindStaking(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StakingTransactor{contract: contract}, nil
}

// NewStakingFilterer creates a new log filterer instance of Staking, bound to a specific deployed contract.
func NewStakingFilterer(address common.Address, filterer bind.ContractFilterer) (*StakingFilterer, error) {
	contract, err := bindStaking(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StakingFilterer{contract: contract}, nil
}

// bindStaking binds a generic wrapper to an already deployed contract.
func bindStaking(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staking *StakingRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Staking.Contract.StakingCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staking *StakingRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.Contract.StakingTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staking *StakingRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staking.Contract.StakingTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staking *StakingCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Staking.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staking *StakingTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staking *StakingTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staking.Contract.contract.Transact(opts, method, params...)
}

// DBDECIMAL is a free data retrieval call binding the contract method 0x91bf6960.
//
// Solidity: function DBDECIMAL() constant returns(uint256)
func (_Staking *StakingCaller) DBDECIMAL(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "DBDECIMAL")
	return *ret0, err
}

// DBDECIMAL is a free data retrieval call binding the contract method 0x91bf6960.
//
// Solidity: function DBDECIMAL() constant returns(uint256)
func (_Staking *StakingSession) DBDECIMAL() (*big.Int, error) {
	return _Staking.Contract.DBDECIMAL(&_Staking.CallOpts)
}

// DBDECIMAL is a free data retrieval call binding the contract method 0x91bf6960.
//
// Solidity: function DBDECIMAL() constant returns(uint256)
func (_Staking *StakingCallerSession) DBDECIMAL() (*big.Int, error) {
	return _Staking.Contract.DBDECIMAL(&_Staking.CallOpts)
}

// DBTOKEN is a free data retrieval call binding the contract method 0xd2a02541.
//
// Solidity: function DBTOKEN() constant returns(address)
func (_Staking *StakingCaller) DBTOKEN(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "DBTOKEN")
	return *ret0, err
}

// DBTOKEN is a free data retrieval call binding the contract method 0xd2a02541.
//
// Solidity: function DBTOKEN() constant returns(address)
func (_Staking *StakingSession) DBTOKEN() (common.Address, error) {
	return _Staking.Contract.DBTOKEN(&_Staking.CallOpts)
}

// DBTOKEN is a free data retrieval call binding the contract method 0xd2a02541.
//
// Solidity: function DBTOKEN() constant returns(address)
func (_Staking *StakingCallerSession) DBTOKEN() (common.Address, error) {
	return _Staking.Contract.DBTOKEN(&_Staking.CallOpts)
}

// DOSDECIMAL is a free data retrieval call binding the contract method 0xc48f4d47.
//
// Solidity: function DOSDECIMAL() constant returns(uint256)
func (_Staking *StakingCaller) DOSDECIMAL(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "DOSDECIMAL")
	return *ret0, err
}

// DOSDECIMAL is a free data retrieval call binding the contract method 0xc48f4d47.
//
// Solidity: function DOSDECIMAL() constant returns(uint256)
func (_Staking *StakingSession) DOSDECIMAL() (*big.Int, error) {
	return _Staking.Contract.DOSDECIMAL(&_Staking.CallOpts)
}

// DOSDECIMAL is a free data retrieval call binding the contract method 0xc48f4d47.
//
// Solidity: function DOSDECIMAL() constant returns(uint256)
func (_Staking *StakingCallerSession) DOSDECIMAL() (*big.Int, error) {
	return _Staking.Contract.DOSDECIMAL(&_Staking.CallOpts)
}

// DOSTOKEN is a free data retrieval call binding the contract method 0x0fd1d0ea.
//
// Solidity: function DOSTOKEN() constant returns(address)
func (_Staking *StakingCaller) DOSTOKEN(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "DOSTOKEN")
	return *ret0, err
}

// DOSTOKEN is a free data retrieval call binding the contract method 0x0fd1d0ea.
//
// Solidity: function DOSTOKEN() constant returns(address)
func (_Staking *StakingSession) DOSTOKEN() (common.Address, error) {
	return _Staking.Contract.DOSTOKEN(&_Staking.CallOpts)
}

// DOSTOKEN is a free data retrieval call binding the contract method 0x0fd1d0ea.
//
// Solidity: function DOSTOKEN() constant returns(address)
func (_Staking *StakingCallerSession) DOSTOKEN() (common.Address, error) {
	return _Staking.Contract.DOSTOKEN(&_Staking.CallOpts)
}

// ONEYEAR is a free data retrieval call binding the contract method 0x195cb3ab.
//
// Solidity: function ONEYEAR() constant returns(uint256)
func (_Staking *StakingCaller) ONEYEAR(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "ONEYEAR")
	return *ret0, err
}

// ONEYEAR is a free data retrieval call binding the contract method 0x195cb3ab.
//
// Solidity: function ONEYEAR() constant returns(uint256)
func (_Staking *StakingSession) ONEYEAR() (*big.Int, error) {
	return _Staking.Contract.ONEYEAR(&_Staking.CallOpts)
}

// ONEYEAR is a free data retrieval call binding the contract method 0x195cb3ab.
//
// Solidity: function ONEYEAR() constant returns(uint256)
func (_Staking *StakingCallerSession) ONEYEAR() (*big.Int, error) {
	return _Staking.Contract.ONEYEAR(&_Staking.CallOpts)
}

// AccumulatedRewardRate is a free data retrieval call binding the contract method 0x193b9497.
//
// Solidity: function accumulatedRewardRate() constant returns(uint256)
func (_Staking *StakingCaller) AccumulatedRewardRate(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "accumulatedRewardRate")
	return *ret0, err
}

// AccumulatedRewardRate is a free data retrieval call binding the contract method 0x193b9497.
//
// Solidity: function accumulatedRewardRate() constant returns(uint256)
func (_Staking *StakingSession) AccumulatedRewardRate() (*big.Int, error) {
	return _Staking.Contract.AccumulatedRewardRate(&_Staking.CallOpts)
}

// AccumulatedRewardRate is a free data retrieval call binding the contract method 0x193b9497.
//
// Solidity: function accumulatedRewardRate() constant returns(uint256)
func (_Staking *StakingCallerSession) AccumulatedRewardRate() (*big.Int, error) {
	return _Staking.Contract.AccumulatedRewardRate(&_Staking.CallOpts)
}

// AddressBridge is a free data retrieval call binding the contract method 0x76cffa53.
//
// Solidity: function addressBridge() constant returns(address)
func (_Staking *StakingCaller) AddressBridge(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "addressBridge")
	return *ret0, err
}

// AddressBridge is a free data retrieval call binding the contract method 0x76cffa53.
//
// Solidity: function addressBridge() constant returns(address)
func (_Staking *StakingSession) AddressBridge() (common.Address, error) {
	return _Staking.Contract.AddressBridge(&_Staking.CallOpts)
}

// AddressBridge is a free data retrieval call binding the contract method 0x76cffa53.
//
// Solidity: function addressBridge() constant returns(address)
func (_Staking *StakingCallerSession) AddressBridge() (common.Address, error) {
	return _Staking.Contract.AddressBridge(&_Staking.CallOpts)
}

// BridgeAddr is a free data retrieval call binding the contract method 0x91874ef7.
//
// Solidity: function bridgeAddr() constant returns(address)
func (_Staking *StakingCaller) BridgeAddr(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "bridgeAddr")
	return *ret0, err
}

// BridgeAddr is a free data retrieval call binding the contract method 0x91874ef7.
//
// Solidity: function bridgeAddr() constant returns(address)
func (_Staking *StakingSession) BridgeAddr() (common.Address, error) {
	return _Staking.Contract.BridgeAddr(&_Staking.CallOpts)
}

// BridgeAddr is a free data retrieval call binding the contract method 0x91874ef7.
//
// Solidity: function bridgeAddr() constant returns(address)
func (_Staking *StakingCallerSession) BridgeAddr() (common.Address, error) {
	return _Staking.Contract.BridgeAddr(&_Staking.CallOpts)
}

// CirculatingSupply is a free data retrieval call binding the contract method 0x9358928b.
//
// Solidity: function circulatingSupply() constant returns(uint256)
func (_Staking *StakingCaller) CirculatingSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "circulatingSupply")
	return *ret0, err
}

// CirculatingSupply is a free data retrieval call binding the contract method 0x9358928b.
//
// Solidity: function circulatingSupply() constant returns(uint256)
func (_Staking *StakingSession) CirculatingSupply() (*big.Int, error) {
	return _Staking.Contract.CirculatingSupply(&_Staking.CallOpts)
}

// CirculatingSupply is a free data retrieval call binding the contract method 0x9358928b.
//
// Solidity: function circulatingSupply() constant returns(uint256)
func (_Staking *StakingCallerSession) CirculatingSupply() (*big.Int, error) {
	return _Staking.Contract.CirculatingSupply(&_Staking.CallOpts)
}

// Delegators is a free data retrieval call binding the contract method 0xa2526bd3.
//
// Solidity: function delegators(address , address ) constant returns(address delegatedNode, uint256 delegatedAmount, uint256 accumulatedReward, uint256 accumulatedRewardRate, uint256 pendingWithdraw)
func (_Staking *StakingCaller) Delegators(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address) (struct {
	DelegatedNode         common.Address
	DelegatedAmount       *big.Int
	AccumulatedReward     *big.Int
	AccumulatedRewardRate *big.Int
	PendingWithdraw       *big.Int
}, error) {
	ret := new(struct {
		DelegatedNode         common.Address
		DelegatedAmount       *big.Int
		AccumulatedReward     *big.Int
		AccumulatedRewardRate *big.Int
		PendingWithdraw       *big.Int
	})
	out := ret
	err := _Staking.contract.Call(opts, out, "delegators", arg0, arg1)
	return *ret, err
}

// Delegators is a free data retrieval call binding the contract method 0xa2526bd3.
//
// Solidity: function delegators(address , address ) constant returns(address delegatedNode, uint256 delegatedAmount, uint256 accumulatedReward, uint256 accumulatedRewardRate, uint256 pendingWithdraw)
func (_Staking *StakingSession) Delegators(arg0 common.Address, arg1 common.Address) (struct {
	DelegatedNode         common.Address
	DelegatedAmount       *big.Int
	AccumulatedReward     *big.Int
	AccumulatedRewardRate *big.Int
	PendingWithdraw       *big.Int
}, error) {
	return _Staking.Contract.Delegators(&_Staking.CallOpts, arg0, arg1)
}

// Delegators is a free data retrieval call binding the contract method 0xa2526bd3.
//
// Solidity: function delegators(address , address ) constant returns(address delegatedNode, uint256 delegatedAmount, uint256 accumulatedReward, uint256 accumulatedRewardRate, uint256 pendingWithdraw)
func (_Staking *StakingCallerSession) Delegators(arg0 common.Address, arg1 common.Address) (struct {
	DelegatedNode         common.Address
	DelegatedAmount       *big.Int
	AccumulatedReward     *big.Int
	AccumulatedRewardRate *big.Int
	PendingWithdraw       *big.Int
}, error) {
	return _Staking.Contract.Delegators(&_Staking.CallOpts, arg0, arg1)
}

// DropburnMaxQuota is a free data retrieval call binding the contract method 0xe8c3470c.
//
// Solidity: function dropburnMaxQuota() constant returns(uint256)
func (_Staking *StakingCaller) DropburnMaxQuota(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "dropburnMaxQuota")
	return *ret0, err
}

// DropburnMaxQuota is a free data retrieval call binding the contract method 0xe8c3470c.
//
// Solidity: function dropburnMaxQuota() constant returns(uint256)
func (_Staking *StakingSession) DropburnMaxQuota() (*big.Int, error) {
	return _Staking.Contract.DropburnMaxQuota(&_Staking.CallOpts)
}

// DropburnMaxQuota is a free data retrieval call binding the contract method 0xe8c3470c.
//
// Solidity: function dropburnMaxQuota() constant returns(uint256)
func (_Staking *StakingCallerSession) DropburnMaxQuota() (*big.Int, error) {
	return _Staking.Contract.DropburnMaxQuota(&_Staking.CallOpts)
}

// GetCurrentAPR is a free data retrieval call binding the contract method 0x21ae05c8.
//
// Solidity: function getCurrentAPR() constant returns(uint256)
func (_Staking *StakingCaller) GetCurrentAPR(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "getCurrentAPR")
	return *ret0, err
}

// GetCurrentAPR is a free data retrieval call binding the contract method 0x21ae05c8.
//
// Solidity: function getCurrentAPR() constant returns(uint256)
func (_Staking *StakingSession) GetCurrentAPR() (*big.Int, error) {
	return _Staking.Contract.GetCurrentAPR(&_Staking.CallOpts)
}

// GetCurrentAPR is a free data retrieval call binding the contract method 0x21ae05c8.
//
// Solidity: function getCurrentAPR() constant returns(uint256)
func (_Staking *StakingCallerSession) GetCurrentAPR() (*big.Int, error) {
	return _Staking.Contract.GetCurrentAPR(&_Staking.CallOpts)
}

// GetDelegatorRewardTokens is a free data retrieval call binding the contract method 0xd0e301f0.
//
// Solidity: function getDelegatorRewardTokens(address _delegator, address _nodeAddr) constant returns(uint256)
func (_Staking *StakingCaller) GetDelegatorRewardTokens(opts *bind.CallOpts, _delegator common.Address, _nodeAddr common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "getDelegatorRewardTokens", _delegator, _nodeAddr)
	return *ret0, err
}

// GetDelegatorRewardTokens is a free data retrieval call binding the contract method 0xd0e301f0.
//
// Solidity: function getDelegatorRewardTokens(address _delegator, address _nodeAddr) constant returns(uint256)
func (_Staking *StakingSession) GetDelegatorRewardTokens(_delegator common.Address, _nodeAddr common.Address) (*big.Int, error) {
	return _Staking.Contract.GetDelegatorRewardTokens(&_Staking.CallOpts, _delegator, _nodeAddr)
}

// GetDelegatorRewardTokens is a free data retrieval call binding the contract method 0xd0e301f0.
//
// Solidity: function getDelegatorRewardTokens(address _delegator, address _nodeAddr) constant returns(uint256)
func (_Staking *StakingCallerSession) GetDelegatorRewardTokens(_delegator common.Address, _nodeAddr common.Address) (*big.Int, error) {
	return _Staking.Contract.GetDelegatorRewardTokens(&_Staking.CallOpts, _delegator, _nodeAddr)
}

// GetNodeAddrs is a free data retrieval call binding the contract method 0x1017bf56.
//
// Solidity: function getNodeAddrs() constant returns(address[])
func (_Staking *StakingCaller) GetNodeAddrs(opts *bind.CallOpts) ([]common.Address, error) {
	var (
		ret0 = new([]common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "getNodeAddrs")
	return *ret0, err
}

// GetNodeAddrs is a free data retrieval call binding the contract method 0x1017bf56.
//
// Solidity: function getNodeAddrs() constant returns(address[])
func (_Staking *StakingSession) GetNodeAddrs() ([]common.Address, error) {
	return _Staking.Contract.GetNodeAddrs(&_Staking.CallOpts)
}

// GetNodeAddrs is a free data retrieval call binding the contract method 0x1017bf56.
//
// Solidity: function getNodeAddrs() constant returns(address[])
func (_Staking *StakingCallerSession) GetNodeAddrs() ([]common.Address, error) {
	return _Staking.Contract.GetNodeAddrs(&_Staking.CallOpts)
}

// GetNodeRewardTokens is a free data retrieval call binding the contract method 0x5bfd61d4.
//
// Solidity: function getNodeRewardTokens(address nodeAddr) constant returns(uint256)
func (_Staking *StakingCaller) GetNodeRewardTokens(opts *bind.CallOpts, nodeAddr common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "getNodeRewardTokens", nodeAddr)
	return *ret0, err
}

// GetNodeRewardTokens is a free data retrieval call binding the contract method 0x5bfd61d4.
//
// Solidity: function getNodeRewardTokens(address nodeAddr) constant returns(uint256)
func (_Staking *StakingSession) GetNodeRewardTokens(nodeAddr common.Address) (*big.Int, error) {
	return _Staking.Contract.GetNodeRewardTokens(&_Staking.CallOpts, nodeAddr)
}

// GetNodeRewardTokens is a free data retrieval call binding the contract method 0x5bfd61d4.
//
// Solidity: function getNodeRewardTokens(address nodeAddr) constant returns(uint256)
func (_Staking *StakingCallerSession) GetNodeRewardTokens(nodeAddr common.Address) (*big.Int, error) {
	return _Staking.Contract.GetNodeRewardTokens(&_Staking.CallOpts, nodeAddr)
}

// GetNodeUptime is a free data retrieval call binding the contract method 0x7f92ca19.
//
// Solidity: function getNodeUptime(address nodeAddr) constant returns(uint256)
func (_Staking *StakingCaller) GetNodeUptime(opts *bind.CallOpts, nodeAddr common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "getNodeUptime", nodeAddr)
	return *ret0, err
}

// GetNodeUptime is a free data retrieval call binding the contract method 0x7f92ca19.
//
// Solidity: function getNodeUptime(address nodeAddr) constant returns(uint256)
func (_Staking *StakingSession) GetNodeUptime(nodeAddr common.Address) (*big.Int, error) {
	return _Staking.Contract.GetNodeUptime(&_Staking.CallOpts, nodeAddr)
}

// GetNodeUptime is a free data retrieval call binding the contract method 0x7f92ca19.
//
// Solidity: function getNodeUptime(address nodeAddr) constant returns(uint256)
func (_Staking *StakingCallerSession) GetNodeUptime(nodeAddr common.Address) (*big.Int, error) {
	return _Staking.Contract.GetNodeUptime(&_Staking.CallOpts, nodeAddr)
}

// InverseStakeRatio is a free data retrieval call binding the contract method 0x0725b32e.
//
// Solidity: function inverseStakeRatio() constant returns(uint256)
func (_Staking *StakingCaller) InverseStakeRatio(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "inverseStakeRatio")
	return *ret0, err
}

// InverseStakeRatio is a free data retrieval call binding the contract method 0x0725b32e.
//
// Solidity: function inverseStakeRatio() constant returns(uint256)
func (_Staking *StakingSession) InverseStakeRatio() (*big.Int, error) {
	return _Staking.Contract.InverseStakeRatio(&_Staking.CallOpts)
}

// InverseStakeRatio is a free data retrieval call binding the contract method 0x0725b32e.
//
// Solidity: function inverseStakeRatio() constant returns(uint256)
func (_Staking *StakingCallerSession) InverseStakeRatio() (*big.Int, error) {
	return _Staking.Contract.InverseStakeRatio(&_Staking.CallOpts)
}

// IsOwner is a free data retrieval call binding the contract method 0x8f32d59b.
//
// Solidity: function isOwner() constant returns(bool)
func (_Staking *StakingCaller) IsOwner(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "isOwner")
	return *ret0, err
}

// IsOwner is a free data retrieval call binding the contract method 0x8f32d59b.
//
// Solidity: function isOwner() constant returns(bool)
func (_Staking *StakingSession) IsOwner() (bool, error) {
	return _Staking.Contract.IsOwner(&_Staking.CallOpts)
}

// IsOwner is a free data retrieval call binding the contract method 0x8f32d59b.
//
// Solidity: function isOwner() constant returns(bool)
func (_Staking *StakingCallerSession) IsOwner() (bool, error) {
	return _Staking.Contract.IsOwner(&_Staking.CallOpts)
}

// IsValidStakingNode is a free data retrieval call binding the contract method 0xa8e8ab38.
//
// Solidity: function isValidStakingNode(address nodeAddr) constant returns(bool)
func (_Staking *StakingCaller) IsValidStakingNode(opts *bind.CallOpts, nodeAddr common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "isValidStakingNode", nodeAddr)
	return *ret0, err
}

// IsValidStakingNode is a free data retrieval call binding the contract method 0xa8e8ab38.
//
// Solidity: function isValidStakingNode(address nodeAddr) constant returns(bool)
func (_Staking *StakingSession) IsValidStakingNode(nodeAddr common.Address) (bool, error) {
	return _Staking.Contract.IsValidStakingNode(&_Staking.CallOpts, nodeAddr)
}

// IsValidStakingNode is a free data retrieval call binding the contract method 0xa8e8ab38.
//
// Solidity: function isValidStakingNode(address nodeAddr) constant returns(bool)
func (_Staking *StakingCallerSession) IsValidStakingNode(nodeAddr common.Address) (bool, error) {
	return _Staking.Contract.IsValidStakingNode(&_Staking.CallOpts, nodeAddr)
}

// LastRateUpdatedTime is a free data retrieval call binding the contract method 0xbe568059.
//
// Solidity: function lastRateUpdatedTime() constant returns(uint256)
func (_Staking *StakingCaller) LastRateUpdatedTime(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "lastRateUpdatedTime")
	return *ret0, err
}

// LastRateUpdatedTime is a free data retrieval call binding the contract method 0xbe568059.
//
// Solidity: function lastRateUpdatedTime() constant returns(uint256)
func (_Staking *StakingSession) LastRateUpdatedTime() (*big.Int, error) {
	return _Staking.Contract.LastRateUpdatedTime(&_Staking.CallOpts)
}

// LastRateUpdatedTime is a free data retrieval call binding the contract method 0xbe568059.
//
// Solidity: function lastRateUpdatedTime() constant returns(uint256)
func (_Staking *StakingCallerSession) LastRateUpdatedTime() (*big.Int, error) {
	return _Staking.Contract.LastRateUpdatedTime(&_Staking.CallOpts)
}

// MaxStakePerNode is a free data retrieval call binding the contract method 0x9dccacc1.
//
// Solidity: function maxStakePerNode() constant returns(uint256)
func (_Staking *StakingCaller) MaxStakePerNode(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "maxStakePerNode")
	return *ret0, err
}

// MaxStakePerNode is a free data retrieval call binding the contract method 0x9dccacc1.
//
// Solidity: function maxStakePerNode() constant returns(uint256)
func (_Staking *StakingSession) MaxStakePerNode() (*big.Int, error) {
	return _Staking.Contract.MaxStakePerNode(&_Staking.CallOpts)
}

// MaxStakePerNode is a free data retrieval call binding the contract method 0x9dccacc1.
//
// Solidity: function maxStakePerNode() constant returns(uint256)
func (_Staking *StakingCallerSession) MaxStakePerNode() (*big.Int, error) {
	return _Staking.Contract.MaxStakePerNode(&_Staking.CallOpts)
}

// MinStakePerNode is a free data retrieval call binding the contract method 0xe5f95a99.
//
// Solidity: function minStakePerNode() constant returns(uint256)
func (_Staking *StakingCaller) MinStakePerNode(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "minStakePerNode")
	return *ret0, err
}

// MinStakePerNode is a free data retrieval call binding the contract method 0xe5f95a99.
//
// Solidity: function minStakePerNode() constant returns(uint256)
func (_Staking *StakingSession) MinStakePerNode() (*big.Int, error) {
	return _Staking.Contract.MinStakePerNode(&_Staking.CallOpts)
}

// MinStakePerNode is a free data retrieval call binding the contract method 0xe5f95a99.
//
// Solidity: function minStakePerNode() constant returns(uint256)
func (_Staking *StakingCallerSession) MinStakePerNode() (*big.Int, error) {
	return _Staking.Contract.MinStakePerNode(&_Staking.CallOpts)
}

// NodeAddrs is a free data retrieval call binding the contract method 0xb4a26490.
//
// Solidity: function nodeAddrs(uint256 ) constant returns(address)
func (_Staking *StakingCaller) NodeAddrs(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "nodeAddrs", arg0)
	return *ret0, err
}

// NodeAddrs is a free data retrieval call binding the contract method 0xb4a26490.
//
// Solidity: function nodeAddrs(uint256 ) constant returns(address)
func (_Staking *StakingSession) NodeAddrs(arg0 *big.Int) (common.Address, error) {
	return _Staking.Contract.NodeAddrs(&_Staking.CallOpts, arg0)
}

// NodeAddrs is a free data retrieval call binding the contract method 0xb4a26490.
//
// Solidity: function nodeAddrs(uint256 ) constant returns(address)
func (_Staking *StakingCallerSession) NodeAddrs(arg0 *big.Int) (common.Address, error) {
	return _Staking.Contract.NodeAddrs(&_Staking.CallOpts, arg0)
}

// NodeRunners is a free data retrieval call binding the contract method 0xbe4a455f.
//
// Solidity: function nodeRunners(address , address ) constant returns(bool)
func (_Staking *StakingCaller) NodeRunners(opts *bind.CallOpts, arg0 common.Address, arg1 common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "nodeRunners", arg0, arg1)
	return *ret0, err
}

// NodeRunners is a free data retrieval call binding the contract method 0xbe4a455f.
//
// Solidity: function nodeRunners(address , address ) constant returns(bool)
func (_Staking *StakingSession) NodeRunners(arg0 common.Address, arg1 common.Address) (bool, error) {
	return _Staking.Contract.NodeRunners(&_Staking.CallOpts, arg0, arg1)
}

// NodeRunners is a free data retrieval call binding the contract method 0xbe4a455f.
//
// Solidity: function nodeRunners(address , address ) constant returns(bool)
func (_Staking *StakingCallerSession) NodeRunners(arg0 common.Address, arg1 common.Address) (bool, error) {
	return _Staking.Contract.NodeRunners(&_Staking.CallOpts, arg0, arg1)
}

// Nodes is a free data retrieval call binding the contract method 0x189a5a17.
//
// Solidity: function nodes(address ) constant returns(address ownerAddr, uint256 rewardCut, uint256 stakedDB, uint256 selfStakedAmount, uint256 totalOtherDelegatedAmount, uint256 accumulatedReward, uint256 accumulatedRewardRate, uint256 pendingWithdrawToken, uint256 pendingWithdrawDB, uint256 lastStartTime, uint256 lastStopTime, bool running, string description)
func (_Staking *StakingCaller) Nodes(opts *bind.CallOpts, arg0 common.Address) (struct {
	OwnerAddr                 common.Address
	RewardCut                 *big.Int
	StakedDB                  *big.Int
	SelfStakedAmount          *big.Int
	TotalOtherDelegatedAmount *big.Int
	AccumulatedReward         *big.Int
	AccumulatedRewardRate     *big.Int
	PendingWithdrawToken      *big.Int
	PendingWithdrawDB         *big.Int
	LastStartTime             *big.Int
	LastStopTime              *big.Int
	Running                   bool
	Description               string
}, error) {
	ret := new(struct {
		OwnerAddr                 common.Address
		RewardCut                 *big.Int
		StakedDB                  *big.Int
		SelfStakedAmount          *big.Int
		TotalOtherDelegatedAmount *big.Int
		AccumulatedReward         *big.Int
		AccumulatedRewardRate     *big.Int
		PendingWithdrawToken      *big.Int
		PendingWithdrawDB         *big.Int
		LastStartTime             *big.Int
		LastStopTime              *big.Int
		Running                   bool
		Description               string
	})
	out := ret
	err := _Staking.contract.Call(opts, out, "nodes", arg0)
	return *ret, err
}

// Nodes is a free data retrieval call binding the contract method 0x189a5a17.
//
// Solidity: function nodes(address ) constant returns(address ownerAddr, uint256 rewardCut, uint256 stakedDB, uint256 selfStakedAmount, uint256 totalOtherDelegatedAmount, uint256 accumulatedReward, uint256 accumulatedRewardRate, uint256 pendingWithdrawToken, uint256 pendingWithdrawDB, uint256 lastStartTime, uint256 lastStopTime, bool running, string description)
func (_Staking *StakingSession) Nodes(arg0 common.Address) (struct {
	OwnerAddr                 common.Address
	RewardCut                 *big.Int
	StakedDB                  *big.Int
	SelfStakedAmount          *big.Int
	TotalOtherDelegatedAmount *big.Int
	AccumulatedReward         *big.Int
	AccumulatedRewardRate     *big.Int
	PendingWithdrawToken      *big.Int
	PendingWithdrawDB         *big.Int
	LastStartTime             *big.Int
	LastStopTime              *big.Int
	Running                   bool
	Description               string
}, error) {
	return _Staking.Contract.Nodes(&_Staking.CallOpts, arg0)
}

// Nodes is a free data retrieval call binding the contract method 0x189a5a17.
//
// Solidity: function nodes(address ) constant returns(address ownerAddr, uint256 rewardCut, uint256 stakedDB, uint256 selfStakedAmount, uint256 totalOtherDelegatedAmount, uint256 accumulatedReward, uint256 accumulatedRewardRate, uint256 pendingWithdrawToken, uint256 pendingWithdrawDB, uint256 lastStartTime, uint256 lastStopTime, bool running, string description)
func (_Staking *StakingCallerSession) Nodes(arg0 common.Address) (struct {
	OwnerAddr                 common.Address
	RewardCut                 *big.Int
	StakedDB                  *big.Int
	SelfStakedAmount          *big.Int
	TotalOtherDelegatedAmount *big.Int
	AccumulatedReward         *big.Int
	AccumulatedRewardRate     *big.Int
	PendingWithdrawToken      *big.Int
	PendingWithdrawDB         *big.Int
	LastStartTime             *big.Int
	LastStopTime              *big.Int
	Running                   bool
	Description               string
}, error) {
	return _Staking.Contract.Nodes(&_Staking.CallOpts, arg0)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Staking *StakingCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Staking *StakingSession) Owner() (common.Address, error) {
	return _Staking.Contract.Owner(&_Staking.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Staking *StakingCallerSession) Owner() (common.Address, error) {
	return _Staking.Contract.Owner(&_Staking.CallOpts)
}

// RewardRateDelta is a free data retrieval call binding the contract method 0x7c6250ff.
//
// Solidity: function rewardRateDelta() constant returns(uint256)
func (_Staking *StakingCaller) RewardRateDelta(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "rewardRateDelta")
	return *ret0, err
}

// RewardRateDelta is a free data retrieval call binding the contract method 0x7c6250ff.
//
// Solidity: function rewardRateDelta() constant returns(uint256)
func (_Staking *StakingSession) RewardRateDelta() (*big.Int, error) {
	return _Staking.Contract.RewardRateDelta(&_Staking.CallOpts)
}

// RewardRateDelta is a free data retrieval call binding the contract method 0x7c6250ff.
//
// Solidity: function rewardRateDelta() constant returns(uint256)
func (_Staking *StakingCallerSession) RewardRateDelta() (*big.Int, error) {
	return _Staking.Contract.RewardRateDelta(&_Staking.CallOpts)
}

// StakingRewardsVault is a free data retrieval call binding the contract method 0xcd45dbcb.
//
// Solidity: function stakingRewardsVault() constant returns(address)
func (_Staking *StakingCaller) StakingRewardsVault(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "stakingRewardsVault")
	return *ret0, err
}

// StakingRewardsVault is a free data retrieval call binding the contract method 0xcd45dbcb.
//
// Solidity: function stakingRewardsVault() constant returns(address)
func (_Staking *StakingSession) StakingRewardsVault() (common.Address, error) {
	return _Staking.Contract.StakingRewardsVault(&_Staking.CallOpts)
}

// StakingRewardsVault is a free data retrieval call binding the contract method 0xcd45dbcb.
//
// Solidity: function stakingRewardsVault() constant returns(address)
func (_Staking *StakingCallerSession) StakingRewardsVault() (common.Address, error) {
	return _Staking.Contract.StakingRewardsVault(&_Staking.CallOpts)
}

// TotalStakedTokens is a free data retrieval call binding the contract method 0x3ae73259.
//
// Solidity: function totalStakedTokens() constant returns(uint256)
func (_Staking *StakingCaller) TotalStakedTokens(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "totalStakedTokens")
	return *ret0, err
}

// TotalStakedTokens is a free data retrieval call binding the contract method 0x3ae73259.
//
// Solidity: function totalStakedTokens() constant returns(uint256)
func (_Staking *StakingSession) TotalStakedTokens() (*big.Int, error) {
	return _Staking.Contract.TotalStakedTokens(&_Staking.CallOpts)
}

// TotalStakedTokens is a free data retrieval call binding the contract method 0x3ae73259.
//
// Solidity: function totalStakedTokens() constant returns(uint256)
func (_Staking *StakingCallerSession) TotalStakedTokens() (*big.Int, error) {
	return _Staking.Contract.TotalStakedTokens(&_Staking.CallOpts)
}

// UnbondDuration is a free data retrieval call binding the contract method 0xc4393444.
//
// Solidity: function unbondDuration() constant returns(uint256)
func (_Staking *StakingCaller) UnbondDuration(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "unbondDuration")
	return *ret0, err
}

// UnbondDuration is a free data retrieval call binding the contract method 0xc4393444.
//
// Solidity: function unbondDuration() constant returns(uint256)
func (_Staking *StakingSession) UnbondDuration() (*big.Int, error) {
	return _Staking.Contract.UnbondDuration(&_Staking.CallOpts)
}

// UnbondDuration is a free data retrieval call binding the contract method 0xc4393444.
//
// Solidity: function unbondDuration() constant returns(uint256)
func (_Staking *StakingCallerSession) UnbondDuration() (*big.Int, error) {
	return _Staking.Contract.UnbondDuration(&_Staking.CallOpts)
}

// Delegate is a paid mutator transaction binding the contract method 0x08bbb824.
//
// Solidity: function delegate(uint256 _tokenAmount, address _nodeAddr) returns()
func (_Staking *StakingTransactor) Delegate(opts *bind.TransactOpts, _tokenAmount *big.Int, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "delegate", _tokenAmount, _nodeAddr)
}

// Delegate is a paid mutator transaction binding the contract method 0x08bbb824.
//
// Solidity: function delegate(uint256 _tokenAmount, address _nodeAddr) returns()
func (_Staking *StakingSession) Delegate(_tokenAmount *big.Int, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.Delegate(&_Staking.TransactOpts, _tokenAmount, _nodeAddr)
}

// Delegate is a paid mutator transaction binding the contract method 0x08bbb824.
//
// Solidity: function delegate(uint256 _tokenAmount, address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) Delegate(_tokenAmount *big.Int, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.Delegate(&_Staking.TransactOpts, _tokenAmount, _nodeAddr)
}

// DelegatorChekcReward is a paid mutator transaction binding the contract method 0x8ac80108.
//
// Solidity: function delegatorChekcReward(address _nodeAddr) returns(uint256)
func (_Staking *StakingTransactor) DelegatorChekcReward(opts *bind.TransactOpts, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "delegatorChekcReward", _nodeAddr)
}

// DelegatorChekcReward is a paid mutator transaction binding the contract method 0x8ac80108.
//
// Solidity: function delegatorChekcReward(address _nodeAddr) returns(uint256)
func (_Staking *StakingSession) DelegatorChekcReward(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.DelegatorChekcReward(&_Staking.TransactOpts, _nodeAddr)
}

// DelegatorChekcReward is a paid mutator transaction binding the contract method 0x8ac80108.
//
// Solidity: function delegatorChekcReward(address _nodeAddr) returns(uint256)
func (_Staking *StakingTransactorSession) DelegatorChekcReward(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.DelegatorChekcReward(&_Staking.TransactOpts, _nodeAddr)
}

// DelegatorClaimReward is a paid mutator transaction binding the contract method 0x1cac57ec.
//
// Solidity: function delegatorClaimReward(address _nodeAddr) returns()
func (_Staking *StakingTransactor) DelegatorClaimReward(opts *bind.TransactOpts, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "delegatorClaimReward", _nodeAddr)
}

// DelegatorClaimReward is a paid mutator transaction binding the contract method 0x1cac57ec.
//
// Solidity: function delegatorClaimReward(address _nodeAddr) returns()
func (_Staking *StakingSession) DelegatorClaimReward(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.DelegatorClaimReward(&_Staking.TransactOpts, _nodeAddr)
}

// DelegatorClaimReward is a paid mutator transaction binding the contract method 0x1cac57ec.
//
// Solidity: function delegatorClaimReward(address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) DelegatorClaimReward(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.DelegatorClaimReward(&_Staking.TransactOpts, _nodeAddr)
}

// DelegatorUnbond is a paid mutator transaction binding the contract method 0x95d516dd.
//
// Solidity: function delegatorUnbond(uint256 _tokenAmount, address _nodeAddr) returns()
func (_Staking *StakingTransactor) DelegatorUnbond(opts *bind.TransactOpts, _tokenAmount *big.Int, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "delegatorUnbond", _tokenAmount, _nodeAddr)
}

// DelegatorUnbond is a paid mutator transaction binding the contract method 0x95d516dd.
//
// Solidity: function delegatorUnbond(uint256 _tokenAmount, address _nodeAddr) returns()
func (_Staking *StakingSession) DelegatorUnbond(_tokenAmount *big.Int, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.DelegatorUnbond(&_Staking.TransactOpts, _tokenAmount, _nodeAddr)
}

// DelegatorUnbond is a paid mutator transaction binding the contract method 0x95d516dd.
//
// Solidity: function delegatorUnbond(uint256 _tokenAmount, address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) DelegatorUnbond(_tokenAmount *big.Int, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.DelegatorUnbond(&_Staking.TransactOpts, _tokenAmount, _nodeAddr)
}

// DelegatorWithdraw is a paid mutator transaction binding the contract method 0xc314bb99.
//
// Solidity: function delegatorWithdraw(address _nodeAddr) returns()
func (_Staking *StakingTransactor) DelegatorWithdraw(opts *bind.TransactOpts, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "delegatorWithdraw", _nodeAddr)
}

// DelegatorWithdraw is a paid mutator transaction binding the contract method 0xc314bb99.
//
// Solidity: function delegatorWithdraw(address _nodeAddr) returns()
func (_Staking *StakingSession) DelegatorWithdraw(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.DelegatorWithdraw(&_Staking.TransactOpts, _nodeAddr)
}

// DelegatorWithdraw is a paid mutator transaction binding the contract method 0xc314bb99.
//
// Solidity: function delegatorWithdraw(address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) DelegatorWithdraw(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.DelegatorWithdraw(&_Staking.TransactOpts, _nodeAddr)
}

// NewNode is a paid mutator transaction binding the contract method 0x867f121a.
//
// Solidity: function newNode(address _nodeAddr, uint256 _tokenAmount, uint256 _dropburnAmount, uint256 _rewardCut, string _desc) returns()
func (_Staking *StakingTransactor) NewNode(opts *bind.TransactOpts, _nodeAddr common.Address, _tokenAmount *big.Int, _dropburnAmount *big.Int, _rewardCut *big.Int, _desc string) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "newNode", _nodeAddr, _tokenAmount, _dropburnAmount, _rewardCut, _desc)
}

// NewNode is a paid mutator transaction binding the contract method 0x867f121a.
//
// Solidity: function newNode(address _nodeAddr, uint256 _tokenAmount, uint256 _dropburnAmount, uint256 _rewardCut, string _desc) returns()
func (_Staking *StakingSession) NewNode(_nodeAddr common.Address, _tokenAmount *big.Int, _dropburnAmount *big.Int, _rewardCut *big.Int, _desc string) (*types.Transaction, error) {
	return _Staking.Contract.NewNode(&_Staking.TransactOpts, _nodeAddr, _tokenAmount, _dropburnAmount, _rewardCut, _desc)
}

// NewNode is a paid mutator transaction binding the contract method 0x867f121a.
//
// Solidity: function newNode(address _nodeAddr, uint256 _tokenAmount, uint256 _dropburnAmount, uint256 _rewardCut, string _desc) returns()
func (_Staking *StakingTransactorSession) NewNode(_nodeAddr common.Address, _tokenAmount *big.Int, _dropburnAmount *big.Int, _rewardCut *big.Int, _desc string) (*types.Transaction, error) {
	return _Staking.Contract.NewNode(&_Staking.TransactOpts, _nodeAddr, _tokenAmount, _dropburnAmount, _rewardCut, _desc)
}

// NodeChekcReward is a paid mutator transaction binding the contract method 0xf94166e3.
//
// Solidity: function nodeChekcReward(address _nodeAddr) returns(uint256)
func (_Staking *StakingTransactor) NodeChekcReward(opts *bind.TransactOpts, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "nodeChekcReward", _nodeAddr)
}

// NodeChekcReward is a paid mutator transaction binding the contract method 0xf94166e3.
//
// Solidity: function nodeChekcReward(address _nodeAddr) returns(uint256)
func (_Staking *StakingSession) NodeChekcReward(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeChekcReward(&_Staking.TransactOpts, _nodeAddr)
}

// NodeChekcReward is a paid mutator transaction binding the contract method 0xf94166e3.
//
// Solidity: function nodeChekcReward(address _nodeAddr) returns(uint256)
func (_Staking *StakingTransactorSession) NodeChekcReward(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeChekcReward(&_Staking.TransactOpts, _nodeAddr)
}

// NodeClaimReward is a paid mutator transaction binding the contract method 0xb41b0f96.
//
// Solidity: function nodeClaimReward(address _nodeAddr) returns()
func (_Staking *StakingTransactor) NodeClaimReward(opts *bind.TransactOpts, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "nodeClaimReward", _nodeAddr)
}

// NodeClaimReward is a paid mutator transaction binding the contract method 0xb41b0f96.
//
// Solidity: function nodeClaimReward(address _nodeAddr) returns()
func (_Staking *StakingSession) NodeClaimReward(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeClaimReward(&_Staking.TransactOpts, _nodeAddr)
}

// NodeClaimReward is a paid mutator transaction binding the contract method 0xb41b0f96.
//
// Solidity: function nodeClaimReward(address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) NodeClaimReward(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeClaimReward(&_Staking.TransactOpts, _nodeAddr)
}

// NodeStart is a paid mutator transaction binding the contract method 0x4c542d3d.
//
// Solidity: function nodeStart(address _nodeAddr) returns()
func (_Staking *StakingTransactor) NodeStart(opts *bind.TransactOpts, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "nodeStart", _nodeAddr)
}

// NodeStart is a paid mutator transaction binding the contract method 0x4c542d3d.
//
// Solidity: function nodeStart(address _nodeAddr) returns()
func (_Staking *StakingSession) NodeStart(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeStart(&_Staking.TransactOpts, _nodeAddr)
}

// NodeStart is a paid mutator transaction binding the contract method 0x4c542d3d.
//
// Solidity: function nodeStart(address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) NodeStart(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeStart(&_Staking.TransactOpts, _nodeAddr)
}

// NodeStop is a paid mutator transaction binding the contract method 0xc5375c29.
//
// Solidity: function nodeStop(address _nodeAddr) returns()
func (_Staking *StakingTransactor) NodeStop(opts *bind.TransactOpts, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "nodeStop", _nodeAddr)
}

// NodeStop is a paid mutator transaction binding the contract method 0xc5375c29.
//
// Solidity: function nodeStop(address _nodeAddr) returns()
func (_Staking *StakingSession) NodeStop(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeStop(&_Staking.TransactOpts, _nodeAddr)
}

// NodeStop is a paid mutator transaction binding the contract method 0xc5375c29.
//
// Solidity: function nodeStop(address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) NodeStop(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeStop(&_Staking.TransactOpts, _nodeAddr)
}

// NodeTryDelete is a paid mutator transaction binding the contract method 0x1b602ec4.
//
// Solidity: function nodeTryDelete(address _nodeAddr) returns()
func (_Staking *StakingTransactor) NodeTryDelete(opts *bind.TransactOpts, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "nodeTryDelete", _nodeAddr)
}

// NodeTryDelete is a paid mutator transaction binding the contract method 0x1b602ec4.
//
// Solidity: function nodeTryDelete(address _nodeAddr) returns()
func (_Staking *StakingSession) NodeTryDelete(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeTryDelete(&_Staking.TransactOpts, _nodeAddr)
}

// NodeTryDelete is a paid mutator transaction binding the contract method 0x1b602ec4.
//
// Solidity: function nodeTryDelete(address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) NodeTryDelete(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeTryDelete(&_Staking.TransactOpts, _nodeAddr)
}

// NodeUnbond is a paid mutator transaction binding the contract method 0x508b74fe.
//
// Solidity: function nodeUnbond(uint256 _tokenAmount, uint256 _dropburnAmount, address _nodeAddr) returns()
func (_Staking *StakingTransactor) NodeUnbond(opts *bind.TransactOpts, _tokenAmount *big.Int, _dropburnAmount *big.Int, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "nodeUnbond", _tokenAmount, _dropburnAmount, _nodeAddr)
}

// NodeUnbond is a paid mutator transaction binding the contract method 0x508b74fe.
//
// Solidity: function nodeUnbond(uint256 _tokenAmount, uint256 _dropburnAmount, address _nodeAddr) returns()
func (_Staking *StakingSession) NodeUnbond(_tokenAmount *big.Int, _dropburnAmount *big.Int, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeUnbond(&_Staking.TransactOpts, _tokenAmount, _dropburnAmount, _nodeAddr)
}

// NodeUnbond is a paid mutator transaction binding the contract method 0x508b74fe.
//
// Solidity: function nodeUnbond(uint256 _tokenAmount, uint256 _dropburnAmount, address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) NodeUnbond(_tokenAmount *big.Int, _dropburnAmount *big.Int, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeUnbond(&_Staking.TransactOpts, _tokenAmount, _dropburnAmount, _nodeAddr)
}

// NodeUnregister is a paid mutator transaction binding the contract method 0xa2772193.
//
// Solidity: function nodeUnregister(address _nodeAddr) returns()
func (_Staking *StakingTransactor) NodeUnregister(opts *bind.TransactOpts, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "nodeUnregister", _nodeAddr)
}

// NodeUnregister is a paid mutator transaction binding the contract method 0xa2772193.
//
// Solidity: function nodeUnregister(address _nodeAddr) returns()
func (_Staking *StakingSession) NodeUnregister(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeUnregister(&_Staking.TransactOpts, _nodeAddr)
}

// NodeUnregister is a paid mutator transaction binding the contract method 0xa2772193.
//
// Solidity: function nodeUnregister(address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) NodeUnregister(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeUnregister(&_Staking.TransactOpts, _nodeAddr)
}

// NodeWithdraw is a paid mutator transaction binding the contract method 0x4ecea80d.
//
// Solidity: function nodeWithdraw(address _nodeAddr) returns()
func (_Staking *StakingTransactor) NodeWithdraw(opts *bind.TransactOpts, _nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "nodeWithdraw", _nodeAddr)
}

// NodeWithdraw is a paid mutator transaction binding the contract method 0x4ecea80d.
//
// Solidity: function nodeWithdraw(address _nodeAddr) returns()
func (_Staking *StakingSession) NodeWithdraw(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeWithdraw(&_Staking.TransactOpts, _nodeAddr)
}

// NodeWithdraw is a paid mutator transaction binding the contract method 0x4ecea80d.
//
// Solidity: function nodeWithdraw(address _nodeAddr) returns()
func (_Staking *StakingTransactorSession) NodeWithdraw(_nodeAddr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.NodeWithdraw(&_Staking.TransactOpts, _nodeAddr)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Staking *StakingTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Staking *StakingSession) RenounceOwnership() (*types.Transaction, error) {
	return _Staking.Contract.RenounceOwnership(&_Staking.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_Staking *StakingTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _Staking.Contract.RenounceOwnership(&_Staking.TransactOpts)
}

// SetCirculatingSupply is a paid mutator transaction binding the contract method 0xb1764071.
//
// Solidity: function setCirculatingSupply(uint256 _newSupply) returns()
func (_Staking *StakingTransactor) SetCirculatingSupply(opts *bind.TransactOpts, _newSupply *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "setCirculatingSupply", _newSupply)
}

// SetCirculatingSupply is a paid mutator transaction binding the contract method 0xb1764071.
//
// Solidity: function setCirculatingSupply(uint256 _newSupply) returns()
func (_Staking *StakingSession) SetCirculatingSupply(_newSupply *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetCirculatingSupply(&_Staking.TransactOpts, _newSupply)
}

// SetCirculatingSupply is a paid mutator transaction binding the contract method 0xb1764071.
//
// Solidity: function setCirculatingSupply(uint256 _newSupply) returns()
func (_Staking *StakingTransactorSession) SetCirculatingSupply(_newSupply *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetCirculatingSupply(&_Staking.TransactOpts, _newSupply)
}

// SetDropBurnMaxQuota is a paid mutator transaction binding the contract method 0x3f3381e1.
//
// Solidity: function setDropBurnMaxQuota(uint256 _quota) returns()
func (_Staking *StakingTransactor) SetDropBurnMaxQuota(opts *bind.TransactOpts, _quota *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "setDropBurnMaxQuota", _quota)
}

// SetDropBurnMaxQuota is a paid mutator transaction binding the contract method 0x3f3381e1.
//
// Solidity: function setDropBurnMaxQuota(uint256 _quota) returns()
func (_Staking *StakingSession) SetDropBurnMaxQuota(_quota *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetDropBurnMaxQuota(&_Staking.TransactOpts, _quota)
}

// SetDropBurnMaxQuota is a paid mutator transaction binding the contract method 0x3f3381e1.
//
// Solidity: function setDropBurnMaxQuota(uint256 _quota) returns()
func (_Staking *StakingTransactorSession) SetDropBurnMaxQuota(_quota *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetDropBurnMaxQuota(&_Staking.TransactOpts, _quota)
}

// SetMaxStakePerNode is a paid mutator transaction binding the contract method 0x6b5fc6a6.
//
// Solidity: function setMaxStakePerNode(uint256 _maxStake) returns()
func (_Staking *StakingTransactor) SetMaxStakePerNode(opts *bind.TransactOpts, _maxStake *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "setMaxStakePerNode", _maxStake)
}

// SetMaxStakePerNode is a paid mutator transaction binding the contract method 0x6b5fc6a6.
//
// Solidity: function setMaxStakePerNode(uint256 _maxStake) returns()
func (_Staking *StakingSession) SetMaxStakePerNode(_maxStake *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetMaxStakePerNode(&_Staking.TransactOpts, _maxStake)
}

// SetMaxStakePerNode is a paid mutator transaction binding the contract method 0x6b5fc6a6.
//
// Solidity: function setMaxStakePerNode(uint256 _maxStake) returns()
func (_Staking *StakingTransactorSession) SetMaxStakePerNode(_maxStake *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetMaxStakePerNode(&_Staking.TransactOpts, _maxStake)
}

// SetMinStakePerNode is a paid mutator transaction binding the contract method 0x8b0bc845.
//
// Solidity: function setMinStakePerNode(uint256 _minStake) returns()
func (_Staking *StakingTransactor) SetMinStakePerNode(opts *bind.TransactOpts, _minStake *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "setMinStakePerNode", _minStake)
}

// SetMinStakePerNode is a paid mutator transaction binding the contract method 0x8b0bc845.
//
// Solidity: function setMinStakePerNode(uint256 _minStake) returns()
func (_Staking *StakingSession) SetMinStakePerNode(_minStake *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetMinStakePerNode(&_Staking.TransactOpts, _minStake)
}

// SetMinStakePerNode is a paid mutator transaction binding the contract method 0x8b0bc845.
//
// Solidity: function setMinStakePerNode(uint256 _minStake) returns()
func (_Staking *StakingTransactorSession) SetMinStakePerNode(_minStake *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetMinStakePerNode(&_Staking.TransactOpts, _minStake)
}

// SetUnbondDuration is a paid mutator transaction binding the contract method 0xb16d2d58.
//
// Solidity: function setUnbondDuration(uint256 _duration) returns()
func (_Staking *StakingTransactor) SetUnbondDuration(opts *bind.TransactOpts, _duration *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "setUnbondDuration", _duration)
}

// SetUnbondDuration is a paid mutator transaction binding the contract method 0xb16d2d58.
//
// Solidity: function setUnbondDuration(uint256 _duration) returns()
func (_Staking *StakingSession) SetUnbondDuration(_duration *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetUnbondDuration(&_Staking.TransactOpts, _duration)
}

// SetUnbondDuration is a paid mutator transaction binding the contract method 0xb16d2d58.
//
// Solidity: function setUnbondDuration(uint256 _duration) returns()
func (_Staking *StakingTransactorSession) SetUnbondDuration(_duration *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.SetUnbondDuration(&_Staking.TransactOpts, _duration)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Staking *StakingTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Staking *StakingSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Staking.Contract.TransferOwnership(&_Staking.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_Staking *StakingTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _Staking.Contract.TransferOwnership(&_Staking.TransactOpts, newOwner)
}

// UpdateGlobalRewardRate is a paid mutator transaction binding the contract method 0xa5e5b55e.
//
// Solidity: function updateGlobalRewardRate() returns()
func (_Staking *StakingTransactor) UpdateGlobalRewardRate(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "updateGlobalRewardRate")
}

// UpdateGlobalRewardRate is a paid mutator transaction binding the contract method 0xa5e5b55e.
//
// Solidity: function updateGlobalRewardRate() returns()
func (_Staking *StakingSession) UpdateGlobalRewardRate() (*types.Transaction, error) {
	return _Staking.Contract.UpdateGlobalRewardRate(&_Staking.TransactOpts)
}

// UpdateGlobalRewardRate is a paid mutator transaction binding the contract method 0xa5e5b55e.
//
// Solidity: function updateGlobalRewardRate() returns()
func (_Staking *StakingTransactorSession) UpdateGlobalRewardRate() (*types.Transaction, error) {
	return _Staking.Contract.UpdateGlobalRewardRate(&_Staking.TransactOpts)
}

// UpdateNodeStaking is a paid mutator transaction binding the contract method 0x1ece5950.
//
// Solidity: function updateNodeStaking(address _nodeAddr, uint256 _newTokenAmount, uint256 _newDropburnAmount, uint256 _newCut) returns()
func (_Staking *StakingTransactor) UpdateNodeStaking(opts *bind.TransactOpts, _nodeAddr common.Address, _newTokenAmount *big.Int, _newDropburnAmount *big.Int, _newCut *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "updateNodeStaking", _nodeAddr, _newTokenAmount, _newDropburnAmount, _newCut)
}

// UpdateNodeStaking is a paid mutator transaction binding the contract method 0x1ece5950.
//
// Solidity: function updateNodeStaking(address _nodeAddr, uint256 _newTokenAmount, uint256 _newDropburnAmount, uint256 _newCut) returns()
func (_Staking *StakingSession) UpdateNodeStaking(_nodeAddr common.Address, _newTokenAmount *big.Int, _newDropburnAmount *big.Int, _newCut *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.UpdateNodeStaking(&_Staking.TransactOpts, _nodeAddr, _newTokenAmount, _newDropburnAmount, _newCut)
}

// UpdateNodeStaking is a paid mutator transaction binding the contract method 0x1ece5950.
//
// Solidity: function updateNodeStaking(address _nodeAddr, uint256 _newTokenAmount, uint256 _newDropburnAmount, uint256 _newCut) returns()
func (_Staking *StakingTransactorSession) UpdateNodeStaking(_nodeAddr common.Address, _newTokenAmount *big.Int, _newDropburnAmount *big.Int, _newCut *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.UpdateNodeStaking(&_Staking.TransactOpts, _nodeAddr, _newTokenAmount, _newDropburnAmount, _newCut)
}

// StakingDelegateToIterator is returned from FilterDelegateTo and is used to iterate over the raw logs and unpacked data for DelegateTo events raised by the Staking contract.
type StakingDelegateToIterator struct {
	Event *StakingDelegateTo // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingDelegateToIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingDelegateTo)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingDelegateTo)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingDelegateToIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingDelegateToIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingDelegateTo represents a DelegateTo event raised by the Staking contract.
type StakingDelegateTo struct {
	Sender   common.Address
	Total    *big.Int
	NodeAddr common.Address
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterDelegateTo is a free log retrieval operation binding the contract event 0x418fb73ed46b20c69a0bc31bf9eb2793aabeabd4c7fe2cd4760406115cf074c1.
//
// Solidity: event DelegateTo(address indexed sender, uint256 total, address nodeAddr)
func (_Staking *StakingFilterer) FilterDelegateTo(opts *bind.FilterOpts, sender []common.Address) (*StakingDelegateToIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "DelegateTo", senderRule)
	if err != nil {
		return nil, err
	}
	return &StakingDelegateToIterator{contract: _Staking.contract, event: "DelegateTo", logs: logs, sub: sub}, nil
}

// WatchDelegateTo is a free log subscription operation binding the contract event 0x418fb73ed46b20c69a0bc31bf9eb2793aabeabd4c7fe2cd4760406115cf074c1.
//
// Solidity: event DelegateTo(address indexed sender, uint256 total, address nodeAddr)
func (_Staking *StakingFilterer) WatchDelegateTo(opts *bind.WatchOpts, sink chan<- *StakingDelegateTo, sender []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "DelegateTo", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingDelegateTo)
				if err := _Staking.contract.UnpackLog(event, "DelegateTo", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// StakingLogNewNodeIterator is returned from FilterLogNewNode and is used to iterate over the raw logs and unpacked data for LogNewNode events raised by the Staking contract.
type StakingLogNewNodeIterator struct {
	Event *StakingLogNewNode // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingLogNewNodeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingLogNewNode)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingLogNewNode)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingLogNewNodeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingLogNewNodeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingLogNewNode represents a LogNewNode event raised by the Staking contract.
type StakingLogNewNode struct {
	Owner            common.Address
	NodeAddress      common.Address
	SelfStakedAmount *big.Int
	StakedDB         *big.Int
	RewardCut        *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterLogNewNode is a free log retrieval operation binding the contract event 0x30c92196901ae5c26b634311806ab8eb9b4c563bf3fa73946deeda237324446a.
//
// Solidity: event LogNewNode(address indexed owner, address nodeAddress, uint256 selfStakedAmount, uint256 stakedDB, uint256 rewardCut)
func (_Staking *StakingFilterer) FilterLogNewNode(opts *bind.FilterOpts, owner []common.Address) (*StakingLogNewNodeIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "LogNewNode", ownerRule)
	if err != nil {
		return nil, err
	}
	return &StakingLogNewNodeIterator{contract: _Staking.contract, event: "LogNewNode", logs: logs, sub: sub}, nil
}

// WatchLogNewNode is a free log subscription operation binding the contract event 0x30c92196901ae5c26b634311806ab8eb9b4c563bf3fa73946deeda237324446a.
//
// Solidity: event LogNewNode(address indexed owner, address nodeAddress, uint256 selfStakedAmount, uint256 stakedDB, uint256 rewardCut)
func (_Staking *StakingFilterer) WatchLogNewNode(opts *bind.WatchOpts, sink chan<- *StakingLogNewNode, owner []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "LogNewNode", ownerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingLogNewNode)
				if err := _Staking.contract.UnpackLog(event, "LogNewNode", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// StakingOwnershipRenouncedIterator is returned from FilterOwnershipRenounced and is used to iterate over the raw logs and unpacked data for OwnershipRenounced events raised by the Staking contract.
type StakingOwnershipRenouncedIterator struct {
	Event *StakingOwnershipRenounced // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingOwnershipRenouncedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingOwnershipRenounced)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingOwnershipRenounced)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingOwnershipRenouncedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingOwnershipRenouncedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingOwnershipRenounced represents a OwnershipRenounced event raised by the Staking contract.
type StakingOwnershipRenounced struct {
	PreviousOwner common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipRenounced is a free log retrieval operation binding the contract event 0xf8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c64820.
//
// Solidity: event OwnershipRenounced(address indexed previousOwner)
func (_Staking *StakingFilterer) FilterOwnershipRenounced(opts *bind.FilterOpts, previousOwner []common.Address) (*StakingOwnershipRenouncedIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "OwnershipRenounced", previousOwnerRule)
	if err != nil {
		return nil, err
	}
	return &StakingOwnershipRenouncedIterator{contract: _Staking.contract, event: "OwnershipRenounced", logs: logs, sub: sub}, nil
}

// WatchOwnershipRenounced is a free log subscription operation binding the contract event 0xf8df31144d9c2f0f6b59d69b8b98abd5459d07f2742c4df920b25aae33c64820.
//
// Solidity: event OwnershipRenounced(address indexed previousOwner)
func (_Staking *StakingFilterer) WatchOwnershipRenounced(opts *bind.WatchOpts, sink chan<- *StakingOwnershipRenounced, previousOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "OwnershipRenounced", previousOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingOwnershipRenounced)
				if err := _Staking.contract.UnpackLog(event, "OwnershipRenounced", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// StakingOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the Staking contract.
type StakingOwnershipTransferredIterator struct {
	Event *StakingOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingOwnershipTransferred represents a OwnershipTransferred event raised by the Staking contract.
type StakingOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Staking *StakingFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*StakingOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &StakingOwnershipTransferredIterator{contract: _Staking.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_Staking *StakingFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *StakingOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingOwnershipTransferred)
				if err := _Staking.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// StakingRewardWithdrawIterator is returned from FilterRewardWithdraw and is used to iterate over the raw logs and unpacked data for RewardWithdraw events raised by the Staking contract.
type StakingRewardWithdrawIterator struct {
	Event *StakingRewardWithdraw // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRewardWithdrawIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRewardWithdraw)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRewardWithdraw)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRewardWithdrawIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRewardWithdrawIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRewardWithdraw represents a RewardWithdraw event raised by the Staking contract.
type StakingRewardWithdraw struct {
	Sender common.Address
	Total  *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRewardWithdraw is a free log retrieval operation binding the contract event 0x6553897c25961cd3a105492c25576d0552123ee868aca283e90f3b4224d7d177.
//
// Solidity: event RewardWithdraw(address indexed sender, uint256 total)
func (_Staking *StakingFilterer) FilterRewardWithdraw(opts *bind.FilterOpts, sender []common.Address) (*StakingRewardWithdrawIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RewardWithdraw", senderRule)
	if err != nil {
		return nil, err
	}
	return &StakingRewardWithdrawIterator{contract: _Staking.contract, event: "RewardWithdraw", logs: logs, sub: sub}, nil
}

// WatchRewardWithdraw is a free log subscription operation binding the contract event 0x6553897c25961cd3a105492c25576d0552123ee868aca283e90f3b4224d7d177.
//
// Solidity: event RewardWithdraw(address indexed sender, uint256 total)
func (_Staking *StakingFilterer) WatchRewardWithdraw(opts *bind.WatchOpts, sink chan<- *StakingRewardWithdraw, sender []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RewardWithdraw", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRewardWithdraw)
				if err := _Staking.contract.UnpackLog(event, "RewardWithdraw", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// StakingUnbondIterator is returned from FilterUnbond and is used to iterate over the raw logs and unpacked data for Unbond events raised by the Staking contract.
type StakingUnbondIterator struct {
	Event *StakingUnbond // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingUnbondIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingUnbond)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingUnbond)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingUnbondIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingUnbondIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingUnbond represents a Unbond event raised by the Staking contract.
type StakingUnbond struct {
	Sender         common.Address
	TokenAmount    *big.Int
	DropburnAmount *big.Int
	NodeAddr       common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterUnbond is a free log retrieval operation binding the contract event 0x1bcf1da2dc680801f7898e72d42550dffb4a3e26dd3a33ff2b23e9f4f6131e9e.
//
// Solidity: event Unbond(address indexed sender, uint256 tokenAmount, uint256 dropburnAmount, address nodeAddr)
func (_Staking *StakingFilterer) FilterUnbond(opts *bind.FilterOpts, sender []common.Address) (*StakingUnbondIterator, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Staking.contract.FilterLogs(opts, "Unbond", senderRule)
	if err != nil {
		return nil, err
	}
	return &StakingUnbondIterator{contract: _Staking.contract, event: "Unbond", logs: logs, sub: sub}, nil
}

// WatchUnbond is a free log subscription operation binding the contract event 0x1bcf1da2dc680801f7898e72d42550dffb4a3e26dd3a33ff2b23e9f4f6131e9e.
//
// Solidity: event Unbond(address indexed sender, uint256 tokenAmount, uint256 dropburnAmount, address nodeAddr)
func (_Staking *StakingFilterer) WatchUnbond(opts *bind.WatchOpts, sink chan<- *StakingUnbond, sender []common.Address) (event.Subscription, error) {

	var senderRule []interface{}
	for _, senderItem := range sender {
		senderRule = append(senderRule, senderItem)
	}

	logs, sub, err := _Staking.contract.WatchLogs(opts, "Unbond", senderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingUnbond)
				if err := _Staking.contract.UnpackLog(event, "Unbond", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// StakingUpdateCirculatingSupplyIterator is returned from FilterUpdateCirculatingSupply and is used to iterate over the raw logs and unpacked data for UpdateCirculatingSupply events raised by the Staking contract.
type StakingUpdateCirculatingSupplyIterator struct {
	Event *StakingUpdateCirculatingSupply // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingUpdateCirculatingSupplyIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingUpdateCirculatingSupply)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingUpdateCirculatingSupply)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingUpdateCirculatingSupplyIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingUpdateCirculatingSupplyIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingUpdateCirculatingSupply represents a UpdateCirculatingSupply event raised by the Staking contract.
type StakingUpdateCirculatingSupply struct {
	OldCirculatingSupply *big.Int
	NewCirculatingSupply *big.Int
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterUpdateCirculatingSupply is a free log retrieval operation binding the contract event 0xef08ea314c41dc78bc73676b156d3b7802c096dd7a552f7f514a80967aba10ac.
//
// Solidity: event UpdateCirculatingSupply(uint256 oldCirculatingSupply, uint256 newCirculatingSupply)
func (_Staking *StakingFilterer) FilterUpdateCirculatingSupply(opts *bind.FilterOpts) (*StakingUpdateCirculatingSupplyIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "UpdateCirculatingSupply")
	if err != nil {
		return nil, err
	}
	return &StakingUpdateCirculatingSupplyIterator{contract: _Staking.contract, event: "UpdateCirculatingSupply", logs: logs, sub: sub}, nil
}

// WatchUpdateCirculatingSupply is a free log subscription operation binding the contract event 0xef08ea314c41dc78bc73676b156d3b7802c096dd7a552f7f514a80967aba10ac.
//
// Solidity: event UpdateCirculatingSupply(uint256 oldCirculatingSupply, uint256 newCirculatingSupply)
func (_Staking *StakingFilterer) WatchUpdateCirculatingSupply(opts *bind.WatchOpts, sink chan<- *StakingUpdateCirculatingSupply) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "UpdateCirculatingSupply")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingUpdateCirculatingSupply)
				if err := _Staking.contract.UnpackLog(event, "UpdateCirculatingSupply", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// StakingUpdateDropBurnMaxQuotaIterator is returned from FilterUpdateDropBurnMaxQuota and is used to iterate over the raw logs and unpacked data for UpdateDropBurnMaxQuota events raised by the Staking contract.
type StakingUpdateDropBurnMaxQuotaIterator struct {
	Event *StakingUpdateDropBurnMaxQuota // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingUpdateDropBurnMaxQuotaIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingUpdateDropBurnMaxQuota)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingUpdateDropBurnMaxQuota)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingUpdateDropBurnMaxQuotaIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingUpdateDropBurnMaxQuotaIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingUpdateDropBurnMaxQuota represents a UpdateDropBurnMaxQuota event raised by the Staking contract.
type StakingUpdateDropBurnMaxQuota struct {
	OldQuota *big.Int
	NewQuota *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterUpdateDropBurnMaxQuota is a free log retrieval operation binding the contract event 0x0aee95cca46da64ee373e28dee5994361b4002c54035d92932c9825b76382e99.
//
// Solidity: event UpdateDropBurnMaxQuota(uint256 oldQuota, uint256 newQuota)
func (_Staking *StakingFilterer) FilterUpdateDropBurnMaxQuota(opts *bind.FilterOpts) (*StakingUpdateDropBurnMaxQuotaIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "UpdateDropBurnMaxQuota")
	if err != nil {
		return nil, err
	}
	return &StakingUpdateDropBurnMaxQuotaIterator{contract: _Staking.contract, event: "UpdateDropBurnMaxQuota", logs: logs, sub: sub}, nil
}

// WatchUpdateDropBurnMaxQuota is a free log subscription operation binding the contract event 0x0aee95cca46da64ee373e28dee5994361b4002c54035d92932c9825b76382e99.
//
// Solidity: event UpdateDropBurnMaxQuota(uint256 oldQuota, uint256 newQuota)
func (_Staking *StakingFilterer) WatchUpdateDropBurnMaxQuota(opts *bind.WatchOpts, sink chan<- *StakingUpdateDropBurnMaxQuota) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "UpdateDropBurnMaxQuota")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingUpdateDropBurnMaxQuota)
				if err := _Staking.contract.UnpackLog(event, "UpdateDropBurnMaxQuota", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// StakingUpdateMaxStakePerNodeIterator is returned from FilterUpdateMaxStakePerNode and is used to iterate over the raw logs and unpacked data for UpdateMaxStakePerNode events raised by the Staking contract.
type StakingUpdateMaxStakePerNodeIterator struct {
	Event *StakingUpdateMaxStakePerNode // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingUpdateMaxStakePerNodeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingUpdateMaxStakePerNode)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingUpdateMaxStakePerNode)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingUpdateMaxStakePerNodeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingUpdateMaxStakePerNodeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingUpdateMaxStakePerNode represents a UpdateMaxStakePerNode event raised by the Staking contract.
type StakingUpdateMaxStakePerNode struct {
	OldMaxStakePerNode *big.Int
	NewMaxStakePerNode *big.Int
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterUpdateMaxStakePerNode is a free log retrieval operation binding the contract event 0x92b144c2e286a9707a25ca0bcb990cde2f7bb2547eb5af8a0191dff727b6e089.
//
// Solidity: event UpdateMaxStakePerNode(uint256 oldMaxStakePerNode, uint256 newMaxStakePerNode)
func (_Staking *StakingFilterer) FilterUpdateMaxStakePerNode(opts *bind.FilterOpts) (*StakingUpdateMaxStakePerNodeIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "UpdateMaxStakePerNode")
	if err != nil {
		return nil, err
	}
	return &StakingUpdateMaxStakePerNodeIterator{contract: _Staking.contract, event: "UpdateMaxStakePerNode", logs: logs, sub: sub}, nil
}

// WatchUpdateMaxStakePerNode is a free log subscription operation binding the contract event 0x92b144c2e286a9707a25ca0bcb990cde2f7bb2547eb5af8a0191dff727b6e089.
//
// Solidity: event UpdateMaxStakePerNode(uint256 oldMaxStakePerNode, uint256 newMaxStakePerNode)
func (_Staking *StakingFilterer) WatchUpdateMaxStakePerNode(opts *bind.WatchOpts, sink chan<- *StakingUpdateMaxStakePerNode) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "UpdateMaxStakePerNode")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingUpdateMaxStakePerNode)
				if err := _Staking.contract.UnpackLog(event, "UpdateMaxStakePerNode", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// StakingUpdateMinStakePerNodeIterator is returned from FilterUpdateMinStakePerNode and is used to iterate over the raw logs and unpacked data for UpdateMinStakePerNode events raised by the Staking contract.
type StakingUpdateMinStakePerNodeIterator struct {
	Event *StakingUpdateMinStakePerNode // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingUpdateMinStakePerNodeIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingUpdateMinStakePerNode)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingUpdateMinStakePerNode)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingUpdateMinStakePerNodeIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingUpdateMinStakePerNodeIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingUpdateMinStakePerNode represents a UpdateMinStakePerNode event raised by the Staking contract.
type StakingUpdateMinStakePerNode struct {
	OldMinStakePerNode *big.Int
	NewMinStakePerNode *big.Int
	Raw                types.Log // Blockchain specific contextual infos
}

// FilterUpdateMinStakePerNode is a free log retrieval operation binding the contract event 0x89892efa8f66455fa9bf996b1444e79778d71795cf00089fadf89071a3896ebb.
//
// Solidity: event UpdateMinStakePerNode(uint256 oldMinStakePerNode, uint256 newMinStakePerNode)
func (_Staking *StakingFilterer) FilterUpdateMinStakePerNode(opts *bind.FilterOpts) (*StakingUpdateMinStakePerNodeIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "UpdateMinStakePerNode")
	if err != nil {
		return nil, err
	}
	return &StakingUpdateMinStakePerNodeIterator{contract: _Staking.contract, event: "UpdateMinStakePerNode", logs: logs, sub: sub}, nil
}

// WatchUpdateMinStakePerNode is a free log subscription operation binding the contract event 0x89892efa8f66455fa9bf996b1444e79778d71795cf00089fadf89071a3896ebb.
//
// Solidity: event UpdateMinStakePerNode(uint256 oldMinStakePerNode, uint256 newMinStakePerNode)
func (_Staking *StakingFilterer) WatchUpdateMinStakePerNode(opts *bind.WatchOpts, sink chan<- *StakingUpdateMinStakePerNode) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "UpdateMinStakePerNode")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingUpdateMinStakePerNode)
				if err := _Staking.contract.UnpackLog(event, "UpdateMinStakePerNode", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// StakingUpdateUnbondDurationIterator is returned from FilterUpdateUnbondDuration and is used to iterate over the raw logs and unpacked data for UpdateUnbondDuration events raised by the Staking contract.
type StakingUpdateUnbondDurationIterator struct {
	Event *StakingUpdateUnbondDuration // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingUpdateUnbondDurationIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingUpdateUnbondDuration)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingUpdateUnbondDuration)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingUpdateUnbondDurationIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingUpdateUnbondDurationIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingUpdateUnbondDuration represents a UpdateUnbondDuration event raised by the Staking contract.
type StakingUpdateUnbondDuration struct {
	OldDuration *big.Int
	NewDuration *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterUpdateUnbondDuration is a free log retrieval operation binding the contract event 0x8671d68a1c48206a7cde676b141ee222482f2014d09ad75af8f5ee2118af9b99.
//
// Solidity: event UpdateUnbondDuration(uint256 oldDuration, uint256 newDuration)
func (_Staking *StakingFilterer) FilterUpdateUnbondDuration(opts *bind.FilterOpts) (*StakingUpdateUnbondDurationIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "UpdateUnbondDuration")
	if err != nil {
		return nil, err
	}
	return &StakingUpdateUnbondDurationIterator{contract: _Staking.contract, event: "UpdateUnbondDuration", logs: logs, sub: sub}, nil
}

// WatchUpdateUnbondDuration is a free log subscription operation binding the contract event 0x8671d68a1c48206a7cde676b141ee222482f2014d09ad75af8f5ee2118af9b99.
//
// Solidity: event UpdateUnbondDuration(uint256 oldDuration, uint256 newDuration)
func (_Staking *StakingFilterer) WatchUpdateUnbondDuration(opts *bind.WatchOpts, sink chan<- *StakingUpdateUnbondDuration) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "UpdateUnbondDuration")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingUpdateUnbondDuration)
				if err := _Staking.contract.UnpackLog(event, "UpdateUnbondDuration", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}
