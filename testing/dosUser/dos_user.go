package main

import (
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/bshuster-repo/logrus-logstash-hook"

	"github.com/sirupsen/logrus"

	"github.com/DOSNetwork/core/configuration"
	"github.com/DOSNetwork/core/testing/dosUser/eth"
)

const (
	ENVQUERYTIMES = "QUERYTIMES"
	ENVQUERYTYPE  = "QUERYTYPE"
)

const (
	INVALIDQUERYINDEX = 17
	CHECKINTERVAL     = 3
	FINALREPORTDUE    = 10
)

type record struct {
	start     time.Time
	end       time.Time
	version   uint8
	logToEmit *logrus.Entry
}

type querySet struct {
	url      string
	selector string
}

var querySets = []querySet{
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", ""},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.base"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.currency"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.amount"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.NOTVALID"},
	{"https://api.coinmarketcap.com/v1/global/", ""},
	{"https://api.coinmarketcap.com/v1/global/", "$"},
	{"https://api.coinmarketcap.com/v1/global/", "$.total_market_cap_usd"},
	{"https://api.coinmarketcap.com/v1/global/", "$.total_24h_volume_usd"},
	{"https://api.coinmarketcap.com/v1/global/", "$.bitcoin_percentage_of_market_cap"},
	{"https://api.coinmarketcap.com/v1/global/", "$.active_currencies"},
	{"https://api.coinmarketcap.com/v1/global/", "$.active_assets"},
	{"https://api.coinmarketcap.com/v1/global/", "$.active_markets"},
	{"https://api.coinmarketcap.com/v1/global/", "$.last_updated"},
	{"https://api.coinmarketcap.com/v1/global/", "$.NOTVALID"},

	////invalid queries
	//{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "NOTVALID"},
	//{"https://api.coinmarketcap.com/v1/global/", "NOTVALID"},
}

var (
	envTimes        = ""
	envTypes        = ""
	userTestAdaptor = &eth.EthUserAdaptor{}
	counter         = 10
	totalQuery      = 0
	invalidQuery    = 0
	lastQuery       = time.Time{}
	startingTimeMap = make(map[uint8]time.Time)
)

func main() {
	envTypes = os.Getenv(ENVQUERYTYPE)
	if envTypes == "" {
		envTypes = "random"
	}

	log := logrus.New()
	hook, err := logrustash.NewHookWithFields("tcp", "13.52.16.14:9500", "DOS_uer", logrus.Fields{
		"queryType":         envTypes,
		"startingTimestamp": time.Now(),
	})
	log.Hooks.Add(hook)

	envTimes = os.Getenv(ENVQUERYTIMES)
	if envTimes != "" {
		counter, err = strconv.Atoi(envTimes)
		if err != nil {
			log.Warn(err)
		}
	}

	//It also need to connect to bootstrape node to get crential
	bootStrapIP := os.Getenv("BOOTSTRAPIP")
	s := strings.Split(bootStrapIP, ":")
	ip, _ := s[0], s[1]

	//
	config := eth.AMAConfig{}
	err = configuration.LoadConfig("./ama.json", &config)
	if err != nil {
		log.Fatal(err)
	}

	onChainConfig := configuration.OnChainConfig{}
	err = onChainConfig.LoadConfig()
	if err != nil {
		log.Fatal(err)
	}

	chainConfig := onChainConfig.GetChainConfig()

	offChainConfig := configuration.OffChainConfig{}
	err = offChainConfig.LoadConfig()
	if err != nil {
		log.Fatal(err)
	}

	//Wait until contract has group public key
	for {
		tServer := "http://" + ip + ":8080/hasGroupPubkey"
		// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
		resp, err := http.Get(tServer)
		for err != nil {
			log.Warn(err)
			time.Sleep(10 * time.Second)
			resp, err = http.Get(tServer)
		}

		r, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Warn(err)
		}

		if string(r) == "yes" {
			err = resp.Body.Close()
			if err != nil {
				log.Warn(err)
			}
			break
		}
	}

	err = userTestAdaptor.Init(config.AskMeAnythingAddress, &chainConfig)
	if err != nil {
		log.Fatal(err)
	}

	logWithId := log.WithField("Serial", userTestAdaptor.GetAddress().Hex())

	events := make(chan interface{}, 5)
	if err = userTestAdaptor.SubscribeToAll(events); err != nil {
		log.Fatal(err)
	}

	query()

	responseTime := float64(0)
	succRequest := float64(0)
	timeCost := float64(0)
	RqSent := 0
	responseTimeMap := make(map[string][]*record)
	ticker := time.NewTicker(3 * time.Minute)
	for {
		select {
		case event := <-events:
			switch i := event.(type) {
			case *eth.AskMeAnythingSetTimeout:
				logWithId.WithFields(logrus.Fields{
					"logEvent":         "AskMeAnythingSetTimeout",
					"new timeout":      i.NewTimeout.String(),
					"previous timeout": i.PreviousTimeout.String(),
				}).Info()
			case *eth.AskMeAnythingQueryResponseReady:
				if envTypes == "url" {
					logToEmit := logWithId.WithFields(logrus.Fields{
						"logEvent":    "AskMeAnythingQueryResponseReady",
						"requestId":   i.QueryId.String(),
						"QueryResult": i.Result,
						"tx":          i.Tx,
						"blockN":      i.BlockN,
					})
					logRecord, found := responseTimeMap[i.QueryId.String()]
					if found {
						timeCost = time.Since(logRecord[0].start).Seconds()
						responseTime += timeCost
						succRequest++
						logToEmit.Data["timeCost"] = timeCost
						logToEmit.Data["version"] = logRecord[0].version
						logToEmit.Info()
						logRecord = logRecord[1:]
						if len(logRecord) < 1 {
							delete(responseTimeMap, i.QueryId.String())
						}
					} else {
						logToEmit.Warn("Response before sent")
					}
					query()
				}
			case *eth.AskMeAnythingRequestSent:
				RqSent++
				logToEmit := logWithId.WithFields(logrus.Fields{
					"logEvent":  "AskMeAnythingRequestSent",
					"succeed":   i.Succ,
					"requestId": i.RequestId.String(),
					"tx":        i.Tx,
					"blockN":    i.BlockN,
				})
				startingTime, found := startingTimeMap[i.InternalSerial]
				if found {
					logRecord, found := responseTimeMap[i.RequestId.String()]
					if found {
						logRecord = append(logRecord, &record{start: startingTime, version: uint8(len(logRecord))})
					} else {
						responseTimeMap[i.RequestId.String()] = []*record{{start: startingTime, version: 0}}
					}
					logToEmit.Data["startingTime"] = startingTime
				} else {
					logToEmit.Data["startingTime"] = nil
				}
				logToEmit.Info()
			case *eth.AskMeAnythingRandomReady:
				if envTypes == "random" {
					logToEmit := logWithId.WithFields(logrus.Fields{
						"logEvent":        "AskMeAnythingRandomReady",
						"requestId":       i.RequestId.String(),
						"GeneratedRandom": i.GeneratedRandom.String(),
						"tx":              i.Tx,
						"blockN":          i.BlockN,
					})
					logRecord, found := responseTimeMap[i.RequestId.String()]
					if found {
						timeCost = time.Since(logRecord[0].start).Seconds()
						responseTime += timeCost
						succRequest++
						logToEmit.Data["timeCost"] = timeCost
						logToEmit.Data["version"] = logRecord[0].version
						logToEmit.Info()
						logRecord = logRecord[1:]
						if len(logRecord) < 1 {
							delete(responseTimeMap, i.RequestId.String())
						}
					} else {
						logToEmit.Warn("Response before sent")
					}
					query()
				}
			default:
				logWithId.WithFields(logrus.Fields{
					"logEvent": "eventTypeMismatch",
				}).Info()
			}
		case <-ticker.C:
			if time.Since(lastQuery).Minutes() > CHECKINTERVAL {
				if counter > 0 {
					query()
				} else if time.Since(lastQuery).Minutes() > FINALREPORTDUE {
					logWithId.WithFields(logrus.Fields{
						"logEvent":         "FinalReport",
						"averageQueryTime": responseTime / succRequest,
						"succRequest":      succRequest,
						"failRequest":      totalQuery - int(succRequest),
						"invalidQuery":     invalidQuery,
						"requestSent":      RqSent,
						"totalQuery":       totalQuery,
					}).Info()
					for requestId := range responseTimeMap {
						logWithId.WithFields(logrus.Fields{
							"logEvent":  "mapContent",
							"requestId": requestId,
						}).Info()
					}
					fmt.Println(responseTimeMap)
					os.Exit(0)
				}
			}
		}
	}
}

func query() {
	if counter > 0 {
		fmt.Println("counter:", counter)
		switch envTypes {
		case "url":
			lottery := rand.Intn(len(querySets))
			if err := userTestAdaptor.Query(uint8(counter), querySets[lottery].url, querySets[lottery].selector); err != nil {
				fmt.Println(err)
				return
			}
			if lottery >= INVALIDQUERYINDEX {
				invalidQuery++
			}
		case "random":
			if err := userTestAdaptor.GetSafeRandom(uint8(counter)); err != nil {
				fmt.Println(err)
				return
			}
		default:
			if counter%2 == 0 {
				lottery := rand.Intn(len(querySets))
				if err := userTestAdaptor.Query(uint8(counter), querySets[lottery].url, querySets[lottery].selector); err != nil {
					fmt.Println(err)
					return
				}
				if lottery >= INVALIDQUERYINDEX {
					invalidQuery++
				}
			} else {
				if err := userTestAdaptor.GetSafeRandom(uint8(counter)); err != nil {
					fmt.Println(err)
					return
				}
			}
		}
		lastQuery = time.Now()
		startingTimeMap[uint8(counter)] = time.Now()
		counter--
		totalQuery++
	}
}
