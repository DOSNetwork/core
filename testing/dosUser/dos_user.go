package main

import (
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/bshuster-repo/logrus-logstash-hook"

	"github.com/sirupsen/logrus"

	"github.com/DOSNetwork/core/configuration"
	"github.com/DOSNetwork/core/testing/dosUser/eth"
)

const (
	ENVQUERYTIMES = "QUERYTIMES"
	ENVQUERYTYPE  = "QUERYTYPE"
)

const INVALIDQUERYINDEX = 17

type record struct {
	start     time.Time
	end       time.Time
	logToEmit *logrus.Entry
}

type querySet struct {
	url      string
	selector string
}

var querySets = []querySet{
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", ""},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.base"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.currency"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.amount"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.NOTVALID"},
	{"https://api.coinmarketcap.com/v1/global/", ""},
	{"https://api.coinmarketcap.com/v1/global/", "$"},
	{"https://api.coinmarketcap.com/v1/global/", "$.total_market_cap_usd"},
	{"https://api.coinmarketcap.com/v1/global/", "$.total_24h_volume_usd"},
	{"https://api.coinmarketcap.com/v1/global/", "$.bitcoin_percentage_of_market_cap"},
	{"https://api.coinmarketcap.com/v1/global/", "$.active_currencies"},
	{"https://api.coinmarketcap.com/v1/global/", "$.active_assets"},
	{"https://api.coinmarketcap.com/v1/global/", "$.active_markets"},
	{"https://api.coinmarketcap.com/v1/global/", "$.last_updated"},
	{"https://api.coinmarketcap.com/v1/global/", "$.NOTVALID"},

	////invalid queries
	//{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "NOTVALID"},
	//{"https://api.coinmarketcap.com/v1/global/", "NOTVALID"},
}

var (
	envTimes        = ""
	envTypes        = ""
	userTestAdaptor = &eth.EthUserAdaptor{}
	counter         = 10
	totalQuery      = 0
	invalidQuery    = 0
	lastQuery       = time.Time{}
	startingTimeMap = make(map[uint8]time.Time)
)

func main() {
	envTypes = os.Getenv(ENVQUERYTYPE)
	if envTypes == "" {
		envTypes = "random"
	}

	log := logrus.New()
	hook, err := logrustash.NewHookWithFields("udp", "13.52.16.14:9500", "DOS_uer", logrus.Fields{
		"queryType":         envTypes,
		"startingTimestamp": time.Now(),
	})
	log.Hooks.Add(hook)

	envTimes = os.Getenv(ENVQUERYTIMES)
	if envTimes != "" {
		counter, err = strconv.Atoi(envTimes)
		if err != nil {
			log.Warn(err)
		}
	}

	//It also need to connect to bootstrape node to get crential
	bootStrapIP := os.Getenv("BOOTSTRAPIP")
	s := strings.Split(bootStrapIP, ":")
	ip, _ := s[0], s[1]

	//
	config := eth.AMAConfig{}
	err = configuration.LoadConfig("./ama.json", &config)
	if err != nil {
		log.Fatal(err)
	}

	onChainConfig := configuration.OnChainConfig{}
	err = onChainConfig.LoadConfig()
	if err != nil {
		log.Fatal(err)
	}

	chainConfig := onChainConfig.GetChainConfig()

	offChainConfig := configuration.OffChainConfig{}
	err = offChainConfig.LoadConfig()
	if err != nil {
		log.Fatal(err)
	}

	//Wait until contract has group public key
	for {
		tServer := "http://" + ip + ":8080/hasGroupPubkey"
		// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
		resp, err := http.Get(tServer)
		for err != nil {
			log.Warn(err)
			time.Sleep(10 * time.Second)
			resp, err = http.Get(tServer)
		}

		r, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			log.Warn(err)
		}

		if string(r) == "yes" {
			err = resp.Body.Close()
			if err != nil {
				log.Warn(err)
			}
			break
		}
	}

	err = userTestAdaptor.Init(config.AskMeAnythingAddress, &chainConfig)
	if err != nil {
		log.Fatal(err)
	}

	logWithId := log.WithField("Serial", userTestAdaptor.GetAddress().String())

	events := make(chan interface{}, 5)
	userTestAdaptor.SubscribeToAll(events)

	query()

	responseTime := float64(0)
	succRequest := float64(0)
	timeCost := float64(0)
	RspsEvtCnt := 0
	RqSent := 0
	responseTimeMap := make(map[string]*record)
	ticker := time.NewTicker(3 * time.Minute)
	for {
		select {
		case event := <-events:
			switch i := event.(type) {
			case *eth.AskMeAnythingSetTimeout:
				logWithId.WithFields(logrus.Fields{
					"logEvent":         "AskMeAnythingSetTimeout",
					"new timeout":      i.NewTimeout.String(),
					"previous timeout": i.PreviousTimeout.String(),
				}).Info()
			case *eth.AskMeAnythingQueryResponseReady:
				if envTypes == "url" {
					logToEmit := logWithId.WithFields(logrus.Fields{
						"logEvent":    "AskMeAnythingQueryResponseReady",
						"requestId":   i.QueryId.String(),
						"QueryResult": i.Result,
					})
					logRecord, found := responseTimeMap[i.QueryId.String()]
					if found {
						RspsEvtCnt++
						timeCost = time.Since(logRecord.start).Seconds()
						responseTime += timeCost
						succRequest++
						logToEmit.Data["timeCost"] = timeCost
						logToEmit.Info()
						delete(responseTimeMap, i.QueryId.String())
					} else {
						responseTimeMap[i.QueryId.String()] = &record{
							end:       time.Now(),
							logToEmit: logToEmit,
						}
					}
					query()
				}
			case *eth.AskMeAnythingRequestSent:
				RqSent++
				logToEmit := logWithId.WithFields(logrus.Fields{
					"logEvent":  "AskMeAnythingRequestSent",
					"succeed":   i.Succ,
					"requestId": i.RequestId.String(),
					"tx":        i.Tx,
					"blockN":    i.BlockN,
				})
				startingTime, found := startingTimeMap[i.InternalSerial]
				if found {
					logRecord, found := responseTimeMap[i.RequestId.String()]
					if found {
						RspsEvtCnt++
						timeCost = logRecord.end.Sub(startingTime).Seconds()
						responseTime += timeCost
						succRequest++
						logRecord.logToEmit.Data["timeCost"] = timeCost
						logRecord.logToEmit.Info()
						delete(responseTimeMap, i.RequestId.String())
					} else {
						responseTimeMap[i.RequestId.String()] = &record{start: startingTime}
					}
					logToEmit.Data["startingTime"] = startingTime
					delete(startingTimeMap, i.InternalSerial)
				} else {
					logToEmit.Data["startingTime"] = nil
				}
				logToEmit.Info()
			case *eth.AskMeAnythingRandomReady:
				if envTypes == "random" {
					logToEmit := logWithId.WithFields(logrus.Fields{
						"logEvent":        "AskMeAnythingRandomReady",
						"requestId":       i.RequestId.String(),
						"GeneratedRandom": i.GeneratedRandom.String(),
					})
					logRecord, found := responseTimeMap[i.RequestId.String()]
					if found {
						RspsEvtCnt++
						timeCost = time.Since(logRecord.start).Seconds()
						responseTime += timeCost
						succRequest++
						logToEmit.Data["timeCost"] = timeCost
						logToEmit.Info()
						delete(responseTimeMap, i.RequestId.String())
					} else {
						responseTimeMap[i.RequestId.String()] = &record{
							end:       time.Now(),
							logToEmit: logToEmit,
						}
					}
					query()
				}
			default:
				logWithId.WithFields(logrus.Fields{
					"logEvent": "eventTypeMismatch",
				}).Info()
			}
		case <-ticker.C:
			if time.Since(lastQuery).Minutes() > 3 {
				if counter > 0 {
					query()
				} else if time.Since(lastQuery).Minutes() > 10 {
					logWithId.WithFields(logrus.Fields{
						"logEvent":           "FinalReport",
						"averageQueryTime":   responseTime / succRequest,
						"succRequest":        succRequest,
						"failRequest":        totalQuery - int(succRequest),
						"invalidQuery":       invalidQuery,
						"responseEventCount": RspsEvtCnt,
						"requestSent":        RqSent,
					}).Info()
					for requestId := range responseTimeMap {
						logWithId.WithFields(logrus.Fields{
							"logEvent":  "mapContent",
							"requestId": requestId,
						}).Info()
					}
					fmt.Println(responseTimeMap)
					os.Exit(0)
				}
			}
		}
	}
}

func query() {
	if counter > 0 {
		fmt.Println("counter:", counter)
		switch envTypes {
		case "url":
			lottery := rand.Intn(len(querySets))
			userTestAdaptor.Query(uint8(counter), querySets[lottery].url, querySets[lottery].selector)
			if lottery >= INVALIDQUERYINDEX {
				invalidQuery++
			}
		case "random":
			userTestAdaptor.GetSafeRandom(uint8(counter))
		default:
			if counter%2 == 0 {
				lottery := rand.Intn(len(querySets))
				userTestAdaptor.Query(uint8(counter), querySets[lottery].url, querySets[lottery].selector)
				if lottery >= INVALIDQUERYINDEX {
					invalidQuery++
				}
			} else {
				userTestAdaptor.GetSafeRandom(uint8(counter))
			}
		}
		lastQuery = time.Now()
		startingTimeMap[uint8(counter)] = time.Now()
		counter--
		totalQuery++
	}
}
