package main

import (
	"fmt"
	"io/ioutil"
	"log"
	"math/rand"
	"net/http"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/DOSNetwork/core/configuration"
	"github.com/DOSNetwork/core/testing/dosUser/eth"
)

type querySet struct {
	url      string
	selector string
}

var querySets = []querySet{
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", ""},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.base"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.currency"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.amount"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "$.data.NOTVALID"},
	{"https://api.coinbase.com/v2/prices/ETH-USD/spot", "NOTVALID"},
	{"https://api.coinmarketcap.com/v1/global/", ""},
	{"https://api.coinmarketcap.com/v1/global/", "$"},
	{"https://api.coinmarketcap.com/v1/global/", "$.total_market_cap_usd"},
	{"https://api.coinmarketcap.com/v1/global/", "$.total_24h_volume_usd"},
	{"https://api.coinmarketcap.com/v1/global/", "$.bitcoin_percentage_of_market_cap"},
	{"https://api.coinmarketcap.com/v1/global/", "$.active_currencies"},
	{"https://api.coinmarketcap.com/v1/global/", "$.active_assets"},
	{"https://api.coinmarketcap.com/v1/global/", "$.active_markets"},
	{"https://api.coinmarketcap.com/v1/global/", "$.last_updated"},
	{"https://api.coinmarketcap.com/v1/global/", "$.NOTVALID"},
	{"https://api.coinmarketcap.com/v1/global/", "NOTVALID"},
}

const ENVQUERYTIMES = "QUERYTIMES"
const ENVQUERYTYPE = "QUERYTYPE"

func main() {
	var times = 1
	var wg sync.WaitGroup
	var err error

	envTimes := os.Getenv(ENVQUERYTIMES)
	if envTimes != "" {
		times, err = strconv.Atoi(envTimes)
	}

	envTypes := os.Getenv(ENVQUERYTYPE)
	if envTypes == "" {
		envTypes = "random"
	}

	//It also need to connect to bootstrape node to get crential
	bootStrapIP := os.Getenv("BOOTSTRAPIP")
	s := strings.Split(bootStrapIP, ":")
	ip, _ := s[0], s[1]

	//
	config := eth.AMAConfig{}
	configuration.LoadConfig("./ama.json", &config)
	fmt.Println("AMA Address", config.AskMeAnythingAddress)
	onChainConfig := configuration.OnChainConfig{}
	onChainConfig.LoadConfig()
	chainConfig := onChainConfig.GetChainConfig()
	offChainConfig := configuration.OffChainConfig{}
	offChainConfig.LoadConfig()

	//Wait until contract has group public key
	hasGroupPubkey := false
	for !hasGroupPubkey {
		tServer := "http://" + ip + ":8080/hasGroupPubkey"
		// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
		resp, err := http.Get(tServer)
		//start := time.Now()
		for err != nil {
			time.Sleep(10 * time.Second)
			resp, err = http.Get(tServer)
		}

		r, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			fmt.Println(err)
		}
		if string(r) == "yes" {
			hasGroupPubkey = true
		}
		resp.Body.Close()
		if err != nil {
			fmt.Println(err)
			log.Fatal(err)
		}
	}

	userTestAdaptor := &eth.EthUserAdaptor{}
	err = userTestAdaptor.Init(config.AskMeAnythingAddress, &chainConfig)
	if err != nil {
		log.Fatal(err)
	}

	events := make(chan interface{})
	userTestAdaptor.SubscribeToAll(events)
	done := make(chan bool)

	go func() {
	loop:
		for {
			select {
			case event := <-events:
				switch i := event.(type) {
				case *eth.AskMeAnythingSetTimeout:
					fmt.Println("AskMeAnythingSetTimeout")
					fmt.Println("new timeout:", i.NewTimeout)
					fmt.Println("previous timeout:", i.PreviousTimeout)
					fmt.Println("____________________________________________")
					wg.Done()
				case *eth.AskMeAnythingQueryResponseReady:
					fmt.Println("AskMeAnythingQueryResponseReady")
					fmt.Println("Callback Ready Query id:", i.QueryId)
					fmt.Println("result: ", i.Result)
					fmt.Println("____________________________________________")
					wg.Done()
				case *eth.AskMeAnythingRequestSent:

				case *eth.AskMeAnythingRandomReady:
					fmt.Println("AskMeAnythingRandomReady")
					fmt.Println("GeneratedRandom:", i.GeneratedRandom)
					fmt.Println("____________________________________________")
					wg.Done()
				default:
					fmt.Println("type mismatch")
				}
			case _ = <-done:
				fmt.Println("done")
				break loop
			}
		}
		fmt.Println("generate test report")
		wg.Done()
	}()

	fmt.Println("start Query ", times)
	for i := 0; i < times; i++ {
		switch envTypes {
		case "url":
			lottery := rand.Intn(len(querySets))
			userTestAdaptor.Query(querySets[lottery].url, querySets[lottery].selector)
		case "random":
			userTestAdaptor.GetSafeRandom()
		default:
			if i%2 == 0 {
				lottery := rand.Intn(len(querySets))
				userTestAdaptor.Query(querySets[lottery].url, querySets[lottery].selector)
			} else {
				userTestAdaptor.GetSafeRandom()
			}
		}
		wg.Add(1)
	}
	wg.Wait()

	wg.Add(1)
	done <- true
	wg.Wait()
}
